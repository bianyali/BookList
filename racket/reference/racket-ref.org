#+TITLE:       The Racket Reference
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-01-21


* 1. Language Model

  学习计算机包含了很多东西，就拿racket来说，学深了可以涉及到 OS，亦或者 language。 学工程了，就会涉及到 Internet TCP/IP等。 真是不是几个星期几个月就可以搞 定的。 一定要多方面的学习，才能掌握 CS 的基础。 在出国以前，这一定要形成。

** Evaluation Model

   Racket evaluation can be viewed as the simplification of expression to obtain values.

*** Sub-expression and Continuation

    Some simplifications require more than one step.

    An expression that is not a value always be partioned into two parts: a redex, which is the part that changed in a single-step simplification, and the continuation, which is the evaluation context surrounding an expression. That is, the continuation says how to "continue" after the redex is reduced to a value.

    Before some things can be evaluated, some sub-expressions must be evaluated; for example, in the application (- 4 (+ 1 1)), the application of - can not be reduced until the sub-expression (+ 1 1) is reduced.

    Thus, the specification of each syntactic form specifies how (some of) sub-expressions are evaluated, and then how the results are combined to reduced the form away.

    The dynamic extent of an expression is the sequence of evaluation steps during which the expression contains the redex.

*** Tail Position

    What exactly is tail position for recur? The tail position is a position which an expression would return a value from. There are no more forms evaluated after the form in the tail position is evaluat.

    An expression expr1 is in tail position with respect to an enclosing expression expr2: if whenever expr1 becomes a redex, its continuation is the same as was the enclosing expr2's continuation.

    Tail-position specificatons provides a guarantee about the asymptotic space consumption of a computation. In general, the specification of tail positions goes with wach syntatic form, like if.

*** Multiple Return Values

    A Racket expression can evaluate to multiple values, in the same way that a procedure can accept multiple arguments.

    Most continuations expect a particular number of result values.

    In general, the specification of a syntactic form indicates the number of values that produces and the number that it expects from each of its sub-expression. In addition, some procedures (notably values) produce multiple values, and some procedures (notably call-with-values) create continuations internalllly that accept a certain number of values.

*** Top-Level Variables

    A set of top-level variables are available for substitutions on demand during evaluation.

    In Racket, the way definitions appear is just as important as the way that they are used.

    Racket evaluation thus keeps track of both definitions and the current expression, and it extends the sets of definitions in response to evaluating forms such as define.

    Each evaluation step, then, takes the current set of definitions and program to a new set of definitions and program.

    Before a define can be moved into the set of definitions, its right-hand expression must be reduced to a value.

    Using set!, a program can change the value associated with an existing top-level variable.

    Using set!, a program can change the value associated with an existing top-level variable.

    Change the VALUE associated with an EXISTING TOP-LEVEL VARIABLE.

*** Objects and Imperative Update

    In addition to set! for IMPERATIVE UPDATE of top-level variables, various procedures enable the modification of ELEMENTs within a compound data structure. For example, vector-set! modifies the content of a vector.

    To allow such modification to data, we must distinguish between values, which are the results of expressions, and objects, which hold the data reference by a value.

    A few kinds of objects can server directly as values, including booleans, (void), and small exact integers.

    More generally, a value is a reference to an object. For example, a value can be a reference to a particular vector that currently holds the value 10 in its first slot. If an object is modified, then the modification is visible through all copies of the value that reference tha same object.

    In the evaluation model, a set of objects must be carried  along with each step in evaluation, just like the definition set.

    The distinction between a *top-level variable* and an *object reference* is crucial. A topic-level variable is not a *value*; each time a *variable expression* is evaluated, the *value* is *extracted* from the current set of *definitions*. *An object reference* in contrast is a *value*, and therefore *needs no further evaluation*. The model evaluation steps above use angle-bracketd <o1> for an *object reference* to distinguish it from a *variable name*.

    A direct *object reference* can *never appear* in a *text-based* *source program*. A program representation with datum->syntax, however, can *embed direct references* to existing objects.

*** Object Identity and Comparisons

    The eq? operator compares two values, returning #t when the two values refer to the same object. This form of equality is suitable for comparing objects that support imperative update (e.g., to determine that the effect of modifying an object through one reference is visible through another reference). Also, an eq? evaluates quickly, and eq?-based hashing is more lightweight than equal?-based hashing in hash tables.

    Some cases, however, eq? is unsuitable as a comparison operator, because the generation of object is not clearly defined.

*** Garbage Collection

    /About references, weak references, I have lots of things to learn!!!/

    *Weak References* ::

*** Procedure Applications and Local Variables
*** Variables and Locations

    A /variable/ is a placehoder for a value, and expressions in an initial program refer to variables. A /top-level/ variable is both a variable and a location. Any other variable is always replaced by a location at run-time, so that evaluation of expressions involves only locations involves only locations. A single local variable (i.e., a non-top-level, non-module-level variable), such as a procedure argument, can correspond to different locations through different instantiations.

    The replacement of a variable with a location during evaluation implements Racket's /lexical scoping/. For example, when a procedure-argument variable /x/ is replaced by the location /xloc/, then it is replaced throughout the body of the procedure, including any nested lambda forms. As a result, future references of the variable always access the same location.

*** Modules and Module-Level Variables

    Most *definitions* in Racket are in modules. In terms of evaluation, a model is essentially a prefix on a defined name, so that different modules can define the name. That is, a *module-level variable* is like a *top-level variable* from the perspective of evaluation.

    One difference between a module and a top-level definition is that a module can be declared *without* instantiating its module-level definitions. Evaluation of a /require/ *instantiates* (i.e., triggers the instantiation of) a declared module, which creates variables that correspond to its module-level definitions.

**** Phases

     A module can be instantiated in multiple /phases/. A phase is an integer that, again, is effectively a prefix on the names of module-level definitions. A top-level /require/ instantiates a module at phase 0, if the module is not already instantiated at phase 0. A top-level (require (for-syntax ...)) instantiates a module at phase 1 (if it is not already instantiated at that level); for-syntax also has a different binding effect on further program parsing, as described in /Introducing Binding/.

     Within a module, some definitions are shifted by a phase already;

**** The Separate Compilation Guarantee

     When a module is compiled, its phase 1 is instantiated. This can, in turn, trigger the *transitive instantiation* of many other modules at other phases, including phase 1. Racket provide very strong guarantee about this instantiation called "The Separate Compilation Guarantee":

     Any effects of the instantiation of the module's phase 1 due to compilation on the Racket system are discarded.

     The practical consequence of this guarantee is that because effects are never visible, no module can detect whether a module it requires is already compiled.







*** Continuation Frames and Marks

    Every continuation /C/ can be partitioned into continuation frames /C1/, /C2/, ... /Cn/ such that /C = C1[C2[... [Cn]]]/, and no frame /Ci/ can be itself partitioned into smaller continuations. Evaluation steps add and remove frames to the current continuation, typically one at a time.

    Each frame is conceptually annotated with a set of continuation marks. A mark consists of a key and its value; the key is an arbitrary value, and each frame includes at most one make for any key. Various operations set and extract marks from continuations, so that marks can be used to attach information to a dynamic extent. For example, marks can be used to record information for a "stack trace" to be used when an exception is raised, or to implement dynamic scope.

*** Prompts, Delimited Continuations, and Barriers
*** Threads
*** Parameters
*** Exceptions
*** Custodians
** Syntax Model

   The syntax of a Racket program is defined by:
     - *a read pass* that processes a character stream into a syntax object; and
     - *an expand pass* that processes a syntax object to produce one that is fully *parsed*.

   Source code is normally read in read-syntax mode, which produces a syntax object.

   The expand pass recursively processes a syntax object to produce a complete parse of the program.

*** Identifiers and Binding

    An identifier is a source-program entity. Parsing a Racket program reveals that some identifiers correspond to variables, some refer to syntactic forms, and some are quoted to produce a symbol or a syntax object.

    An identifier binds another (i.e., it is a binding) when the former is parsed as a variable and the latter is parsed as a reference to the former; the latter is bound. The scope of a binding is the set of source form to which it applies. The environment of a form is the set of bindings(i.e., it is shadowing) in its environment, so that uses of an identifier refer to the shadowing binding.

**** phase level

     这个没有弄懂

*** Syntax Objects

    A syntax object combines a simpler Racket value, such as a symbol or pair, with *lexical information* about /bindings/, /source-location information/, /syntax properties/, and /tamper status/. In particular, an identifier is represented as a symbol object that combines a symbol with lexical and other information.

    When a syntax object represents a more complex expression than an identifier or simple constant, its internal components can be extracted.

*** Expansion (Parsing)

    Expansion recursively processes a syntax object in a particular phase level.

    A /fully-expanded/ syntax object corresponds to a parse of a program (i.e., a parsed program), and lexical information on its identifiers indicates the parse.













































** The Reader
** The Printer

**
* 4. Datatypes

** 1. Booleans and Equlity
** 2. Numbers
** 3. String?
** 4. Byte Strings
** 5. Characters
** 6. Symbols
** 7. Regular Expresson
** 8. Keywords
** 9. Pairs and Lists
** 10. Mutable Pairs and Lists
** 11. Vectors
** 12. Boxes
** 13. Hash Tables
** 14. Sequences and Streams
           Sequences and streams abstract over iteration of elements in a collection. Sequences allow iteration with for macros or with sequence operations such as sequence-map. Streams are functional sequences that can be used either in a general way or a stream-specific way. Generators are closely related stateful objects that can be converted to a sequence and vice-versa.

***           1. Sequences
              A sequence encapsulates an ordered collection of values. The elements of a sequence can be extracted with one of the for syntax forms, with the procedures returned by sequence-generate, or by converting the sequence into a stream.



***           2. Streams

***           3. Generators

** 15. Dictionaries
** 16. Sets
** 17. Procedures
** 18. Void
** 19. Undefined
* 13. Input and Output

** Ports
