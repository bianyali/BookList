#+TITLE:         Thinking in UML
#+AUTHOR:        Yali Bian
#+DATE:          2015-08-18 Tue


* 1 为什么需要 UML

** 1.1 面向过程还是面向对象

  人们很快发现了问题：编程需要的对象，不但不能够从设计中自然地推导出来.
  而且 强调连续性和过程化的结构化设计 与 事件驱动型的离散对象结构 之间有着难以调和的矛盾。

** 1.2 UML 带来了什么

*** 可视化

    把那些通过文字很难表达清楚的，隐晦的潜台词用简单直观的图形表达出来，准确直观地描述复杂地含义。

    一段描述汽车车窗，方向盘之类地话，看起来很简单，这是因为汽车是我们熟悉地事务。 如果一个不知道汽车地人，靠这段描述去设计一辆汽车地话，一定觉得缺少了很多信息。

    如果信息点比较多，而且相互之间有关系，阅读文字并不容易了解到到底叙述了怎么样地一个逻辑结构。 如果是面向更加复杂地业务需求时，书写或阅读长达几十页地文字，要把所有地信息都关联起来，并且准确地理解，就更加困难了。

    用文字来表达风花雪月是很美地，朦胧美，想象美。 但是要用来说明一个结构，是不太容易地。

    逻辑结构，相互之间关联比较多的话，更好的是用 图形 来表达。

*** RUP

    UML 是一种语言，用来描述软件生产过程中要产生的可视化形式的文档
    指导 programmer 去开发software。
    RUP 是指导如何产生这些文档以及这些文档要讲述什么样的方法。

* 2 建模基础

** 2.1 建模

** 2.2 用例驱动

** 2.3 抽象层次

** 2.4 视图

   视图是人们观察事物的角度。

   恰当的视角可以让观察者更容易的抓住信息的本质。

** 2.5 对象分析方法

* 3 UML 核心元素

** 3.1 版型 － steretype

   这个概念是对 UML 元素基础定义的扩展，在同一个元素基础定义的基础上，赋予特别的含义，使得这个元素适用于特定的场合。

   类的版型有：接口，边界类，实体类，控制类。

   版型可以自定义。

** 3.2 参与者 - actor

*** 基本概念

    参与者（actor）在建模过程中处于核心地位。 actor 是在系统之外与系统交互的某人或某事物。

    柜台职员也参与了业务，但是他们是“业务工人”.

    参与者可以非人： 有些需求并没有人参与，参与者如何确定？

*** 发现参与者

*** 业务主角 － business actor

    业务主角是参与者的一个版型，特别用于定义业务的参与者，在需求阶段使用。 业务主角是与业务系统有着交互的人和事物，他们用来确定业务范围。

*** 业务工人

    没有完整的业务目标，系统不是为他服务的，不是主动的向系统发出动作的。

*** 参与者与涉众的关系

    涉众－stackholder,也称为干系人。

    作为涉众，投资方的一件或许会构成一些约束。
    但是投资方并不会参与系统的建设，它只是从资本拥有这个系统并从将来的收入中获得回报。

*** 参与者和用户的关系

    用户－User 是指系统的使用者，通俗一点就是系统的操作员。
    用户是参与者的代表，或者说是参与者的实例或代理。

    并非所有的参与者都是用户，但是一个用户可以代理多个参与者。

*** 参与者和角色的关系

    角色－Role 是参与者的职责。

    角色是一个抽象的概念，从众多参与者的职责中，抽象出相同的那部分，将其命名而形成一个角色。 一个角色代表系统中的一类职责。

*** 参与者的核心地位

*** 检查点

** 3.3 用例 － Use Case

   用例在 UML 建模中，是最重要的一个元素。因为 UML 是面向对象的，除了用例，其他所有元素都是“封装的”，“独立的”。

*** 基本概念

   Use Case（用例）是一个UML中非常重要的概念，在使用UML的整个软件开发过程中，Use Case处于一个中心地位。用例是对一组动作序列的抽象描述，系统执行这些动作序列，产生相应的结果。这些结果要么反馈给参与者，要么作为其他用例的参数。

   用例定义了一组用例实例，其中每个实例都是系统所执行的一系列操作，这些操作生成特定主角可以观测的值。

   一个用例就是与参与者交互的，并且提供参与者可观测的有意义的结果，的一系列的活动的集合。

*** 用例的特征

    用例有着一系列的特征。 这些特征保证能够正确的捕捉功能性需求，同时这些特征也是判断用例是否准确的依据。

    * 用例是相对独立的
    * 用例的执行结果对参与者来说是可观测的，有意义的
      登陆系统是一个有效的用例，但输入密码却不是。
    * 事情是由一个参与者发起的，不存在没有参与者的用例，用例不应该自动启动。
      也不应该主动启动另一个用例
    * 用例必然是以动宾短语形式出现的
      用例必须有一个动作和动作的受体
    * 一个用例就是一个需求单元，分析单元，设计单元，开发单元，测试单元，甚至部署单元。
      一旦决定了用例，软件开发工作的其他活动都以这个用例为基础，围绕他进行。

*** 用例的粒度

    到底一个大的用例合适，还是分解成多个小用例合适呢？

    在业务建模阶段，用例的粒度以每个用例能够说明一件完整的事情为宜。
    即一个用例可以描述一项完整的业务流程。这将有助于明确需求范围。

    在用例分析阶段，即概念建模阶段，用例的粒度以每个用例能描述一个完整的事件流为宜。
    一个用例描述一项完整业务中的一个步骤。
    采用一些面向对象的方法，归纳和抽象出业务用例的关键概念模型，并为之建模

*** 用例的获得

    用例的定义就是由参与者驱动的，并且给参与者提供可观测的有意义的结果的一系列活动，用例的来源就是参与者对系统的期望。

    发现用例的前提条件是发现参与者，而确定参与者的同时就确定了系统边界。

*** 用例和功能的误区

    在实际应用中，用例是非常容易被误解和误用的。 尤其是习惯了面向过程结构化设计方法的计算机技术人员。
    最普遍的误解就是认为用例就是功能的划分和描述。他们认为一个用例就是一个功能点。
    在这种理解下，用例建模变成了仅仅是较早前需求分析方法中的功能框图的翻版。

    功能实际描述的是输入->计算->输出。DFD图？这可是典型的main 香过程分
    析模式。因此将用例当作功能点的做法实际是在做面向过程的分析。

    面向对象是合理的，以为，面向对象，更加突出的引导大家，将一系列同等事物的功能放到一起，是一个知识积累的过程，相反，面向过程，这是想着，要用到什么，我们就积累什么信息，下次使用，再定义一个类似的信息。 而真正的实践性的面向对象，应该是这个样子的，对象用来存储知识，是一个横向的积累的过程，面向过程是用来应用的，将存储的信息拿出来使用的，进行应用的过程。就如同 UML 中的 对象 和 用例 的关系一样。还如同 js 中的包一样，使用的时候，就是将一个系统的功能放到一个函数中，让这个函数作为接口来实现所有的功能。

    将工程分成两个横截面：
      － 面向知识储备，对应用系统的深入的模块的理解  -> 面向对象：面向模块
      － 面向应用，面向用户，提供接口，将系统积累的强大功能，通过串联使用各个知识部分，通过简洁有效的手段曝露给用户 -> 面向过程，面向命令式

    面向过程，和面向对象的另一个区别： 面向对象在设计的时候，就是按照 模块，实际的知识积累分开的
    面向过程，是在应用过程中，将需要共同使用的东西，共同筹划的东西，抽象出来，形成模块。

*** 业务用例 - business use case

    业务用例是用例版型的一种，专门用于需求阶段的业务建模。
    在为业务领域建立模型时，应该使用这种版型。
    请注意，业务用噢知识普通用例的一个版型，并不是一个新的概念，因此业务用例具有普通用例的所有特征。

*** 概念用例 - conception use case

*** 系统用例

*** 用例实现

** 3.4 边界

   边界本质上时面向对象的一个很重要的概念，与封装的概念同源。

   面向对象里，任何一个对象都有一个边界，外界只能通过这个边界来认识对象，和对象打交道，而面向对象能不是一个进去。

   我们把边界放大了看，对于世界上的任何东西，我们都不能完全掌握他的本质，只能通过它的行为，外观，性质来描述它。 行为也好，外观也吧，这就是这个东西的一个边界，我们就是通过这些边界来认识事物的。

*** 边界决定抽象层次

    自顶向下的方式： 通过缩小边界进而影响到我们可以观察到的事物，这就决定了我们的抽象层次，使得我们的分析可以有条不紊地地进行细化。

    自底向上地方式：先把边界设定到较小地范围，再扩大到整个系统。

    不论那种方式，边界总能够帮助我们很好地把我抽象层次，忽略掉那些边界外的杂音，专心地把当前边界内容地问题搞清楚。

** 3.5 业务实体

   业务实体 是 类（class） 的一种版型， 特别用于在业务建模阶段建立领域模型。

   如果说，参与者和用例描述了我们在这个问题领域的重要手段，那么业务实体就描述了我们使用什么来达到业务目标以及通过什么来纪录这个业务目标。

   业务实体抽象除了问题领域内核心和关键的概念，如果把问题领域比喻成一栋大楼，业务实体就是构成这栋大楼的砖瓦和石头。

   业务实体 :: 代表业务角色执行业务用例时所处理或所使用的事物。 一个业务实体经常代表某个对多个业务用例或用例实例有价值的事物。

   一个好的业务实体不包含关于其使用主体和使用方法的信息。

   业务实体时来自于现实世界的，在我们建模的问题领域里一定能够遭到与它相对应的事物，并且这个事物时参与者在完成其业务目标的过程中使用到或创建出来的。

   // 面向对象，不就是将数据模块化么？

   业务实体一定时在分析业务流程的过程中发现的，而业务流程实际上就是业务用例场景。 这意味着，业务实体必须至少被一个业务用例场景使用或创建，对业务用例没有贡献的事物，既是它是客观存在的，也不应当为它建模。

   最后，业务实体作为类的一个版型，具有对象的所有性质，包括属性和方法，同时也具有对象的独立性，即业务实体只应当包含它本身的固有的特性，而不能包含外界时如何使用它的信息。


*** 业务实体的属性

    属性时用来保存业务实体特征的一个纪录，业务实体的属性集合决定了它的唯一性。

    将面向过程的程序中，可能会一直遇到的这种数据结构和对于改种数据结构的处理方式打包到一起。然后让面向过程的程序，对这个打的包进行，共同使用，就像使用一个高级一点的函数一样，就是所谓的面向对象了把。
    当然，这个打的包一定要比较的清楚易懂，想要做到这个，也就是将这个包定义成类似于现实生活中的实体的方式，这样更加的让人理解把。

    对于函数，想要进行复用，只能进行高阶函数生成，同等类型的函数。
    对于对象的复用，这是进行 “继承”“原型” “module” 这种形式，来实现复用的吧。

*** 业务实体的方法

    方法是访问一个业务实体的句柄，它规定了外部可以怎样使用它。

    对象 和 module 的区别是不是就是 接口－interface 不同啊！！！

    方法是外部能够使用这个业务实体的全部信息。

*** 获取业务实体

** 3.6 包

   包是一种容器，如同文件夹一样，它将某些信息分类，形成逻辑单元。 使用包的目的是为了整合复杂的信息，某些语意上相关或者某方面的信息都可以分包.

   包是 UML 非常常用的一个元素，它最主要的作用就是容纳并为其他元素分类。

   包可以容纳任何 UML 元素，例如用例，业务实体，类图等，也包括子包。

   UML 认为好的包具有高内聚，低耦合的性质。

*** 包的常用版型

    * 领域包 － Domain Package
      领域包用于分类业务领域内的业务单元，每个包代表业务的一个领域，领域包视图可用于展示这些业务领域的高层次关系。

    * 子系统 － Subsystem
      用来分类系统内的逻辑对象并形成子系统

    * 组织结构 － Organization unit
      用来分类业务领域的组织结构

    * 层 － Layer
      用于分类软件中的层次，层可以用于展示软件的架构信息。

** 3.7 分析类

   分析类用于获取系统中主要的“职责簇”。他们代表系统的原型类，是系统必须处理的主要抽象概念的“第一个关口”。

   分析类是跨越需求到设计实现的桥梁。

   分析类是从业务需求向系统设计转化过程中最为主要的元素。他们在高层次抽象出系统实现业务需求的原型，业务需求通过分析类逻辑化，被计算机所了解。

   分析类总共有三个，分别是“边界类－boundary”，“控制类－control” 和 “实体类”，这些“分析类”都是类－class 的版型。

*** 边界类

    边界类是一种对系统外部环境与其内部运行之间的交互进行建模的类。这种交互包括转换事件，并纪录系统表示方式（接口）中的变更。任何有两个交互的关键对象之间都应当考虑建立边界类。

    * 参与者于用例之间应当建立边界类
    * 用例与用例之间如果有交互，应当为其建立边界类
      一个用例如果要访问另一个用例，直接访问内部对象是不好的结构，这样将导致紧耦合的发生。
    * 如果用例与系统边界之外的非人对象有交互，例如第三方系统，应当为为其建立边界类。
    * 在相关联的业务对象有明显的独立型要求，即他们可能在个字的领域内发展和变化，但有希望互不影响时，也应该为他们建立边界类。

*** 控制类

    控制类用于对一个或几个用例所特有的控制行为进行建模。 控制对象（控制类的实例）通常控制其他对象，因此他们的行为具有协调性质。控制类将用例的特有行为进行封装。

    在 UML 的定义中，认为控制类主要起到协调对象的作用，例如从边界类通过控制类访问实体类，或者实体类通过控制类防卫另一个实体类。

    在设计阶段，控制类可以被设计为 Session Bean，COM＋，Server let，java 类，cpp 类等设计类。

    从架构角度来说，控制类主要位于业务逻辑层。控制类的获取对架构设计中的业务逻辑层有着重要的指导意义。

*** 实体类

    实体类是用于对必须存储的信息和相关行为建模的类。 实体类通常是永久性的，他们所具有的属性和关系是长期需要的，又是甚至在系统的整个生存周期。

** 3.8 设计类

    将分析结构转换成实现的元素。

    设计类是系统实施中一个或多个对象的抽象；设计类所对应的对象，取决于实施语言。设计类用于设计模型中，它直接使用与编程语言相同的语言来描述。

    凡事使用过面向对象语言的朋友对类都不会陌生，到了这个阶段，设计类已经直接映射到实现代码了，因此，设计类依赖于实施语言。

    分析类为设计类中说需要的界面，逻辑和数据提供了非常好的抽象基础，设计类可以非常容易和自然地从分析类中演化出来。

    UML 为设计类地概念进行了定义： 设计类由类型，属性和方法构成。设计类的名称，属性和方法也直接映射到编码中相应的class，property，和method。

*** 类

    类对对象进行定义，而对象又实现用例

*** 小结

    设计类是分析设计工作转变为代码的最后一道工序，对大多数熟练的编程着来说并不是问题。

** 3.9 关系

*** 关联关系 － association

    对象之间知道对方的存在。

*** 依赖关系 － dependency

    一个对象的修改或导致另一个对象的修改的关系。

    和关联关系不同的是，依赖关系除了“知道”其他对象的存在，还会使用其他对象的属性或方法。

    依赖是一种特殊的关联关系。

*** 扩展关系 － extends

    与包含关系不同的是，扩展表示的是“可选”， 而不是“必须”，着意味着既是没有扩展用例，基本用例也是完整的。

    使用扩展关系的原因：
    － 表明用例的某一部分是可选的系统行为
    － 表明只在特定条件下，才执行支流

*** 包含关系 － include

    特别用于 用例 模型，说明在执行基本用例的用例使用过程中，插入的行为段。

*** 实现关系 －realize

    用例模型中，连接用例和用例实现，说明基本用例的一个实现。

*** 精化关系 － refine

    特别用于用例模型，一个基本用例可以分解出许多更小关键精化用例。精化用例展示基本用例的核心业务。

*** 泛化关系

    每个用例都应该是独一无二的，用例带有原子特性，所以不赞成使用泛化关系。使用泛化关系，很难描述用例继承了基本用例的什么。过程？还是业务实体？

*** 聚合关系

    聚合关系用于类图，特别用于表示实体对象之间的关系，表达整体由部分构成的语义。

*** 组合关系

    组合关系用于类图，表示实体对象关系，表达整体拥有部分的语义。

** 3.10 组件

   组件是系统中实际存在的可变换部分，它实现特定的功能，符合一套接口标准并实现一组接口。 组件代表系统中的一部分无力实施，包括软件代码（源代码，二进制代码或可执行代码）或等价物（如脚本或命令文件）。

   出于构建化的需要，我们把那些紧密合作的类和接口组合起来实现一组特定的功能，形成一个组件。

*** 完备性

*** 独立性

*** 逻辑性

*** 透明性

** 3.11 节点

   节点是带有至少一个处理器，内存以及可能还带有其他设备的处理元素。

   服务器，工作站，或者客户机都可以称为一个节点。

   节点是应用程序的部署单元。

   节点元素特别用于部署视图，描述应用程序在无力结构上是如何部署在应用环境中的，是一种包含软，硬件环境在内的拓扑结构描述。

*** 分布式应用环境

*** 多设备的应用环境

UML 核心元素就像是语言中的基本词汇，仅有词汇是不可能构成一篇文章的，UML 视图就像是语法，将词汇组成有意义的句子。
