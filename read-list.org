#+TITLE: Books I Read TimeLine

* Read
** ANSI Common Lisp

  * TIME
    1. 2014年12月07日 - 2014年12月17日

  * COMMENT

  * QUOTE

** How to Design Programs

  * TIME
    1. 2014年12月22日 - 2014年12月28日

  * COMMENT

  * QUOTE

** The Racket Guide

  * TIME

    1. 2014年12月29日 - 2015年01月05日
    2. 2015年01月05日 - 2015年01月14日

  * COMMENT

  * QUOTE

** 从一到无穷大

  * TIME

    1. 2014年12月22日 - now

  * COMMENT

  * QUOTE

** 图灵的秘密

  * TIME

    1. 2015年01月03日 - now

  * COMMENT

  * QUOTE

** An Emacs Tutorial for Vim User

  * TIME
    1. 2015年01月04日 - 2015年01月04日

  * COMMENT

  * QUOTE

** The little Schemer

  * TIME
    1. 2015年01月04日 - 2015年01月06日

  * COMMENT

  * QUOTE

** [[www.norvig.com/21-days.html][Teach Yourself Programming in Ten years]]

  * TIME
    1. 2015年01月08日 - 2015年01月08日

  * COMMENT

  * QUOTE
    #+BEGIN_QUOTE
      * A little learning is a dangerous thing.
      * A language that doesn't affect the way you think about programming, is not worth to learn.
      * The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again.
      * Anyone can cook, but only the fearless can be great.
    #+END_QUOTE

** [[http://shop.oreilly.com/product/9781565925090.do#][HTTP: The Definitive Guide]]

  * TIME
    1. 2015年01月07日 - 2015年01月18日

  * COMMENT

    1. 万物皆是数据:
        其实HTTP也好，Internet也好。都是为了进行信息的传递，都是为了人类之间的交流，这和programming language 不谋而合， 都是为了进行信息的传递和交流， programming language 是为了进行信息的处理。其他的所谓的算法和过程都是为了更好的进行信息的处理。将所有的信息都转换成list吧，讲programming language 中的code也用来作为信息吧， 都用list进行表示吧，都是可以的，其他的所谓的markdown， markup language都是另外一种形式的list吧，现在的信息还都是以大量，海量， 大数据著称的数据，其实从复杂程度上来说，只是一个单层的信息数据结构，还没有到达一个多层的复杂的信息呈现上，大多数人类现在还无法理解得高度。
    2. 如果你想学习HTTP协议，除了RFC2616以外，必不可少的三本书:
       1. HTTP: The Definitive Guide
       2. HTTP Developer's Handbook
       3. Web Protocols and Practice
    3. 虽然学习了很多的关于HTTP的知识，但是还有一些知识，这本书没有提到，也就是我要认真学习的

       1. 没有讲解关于CGI以及当前将HTTP与servlet结合到的技术
       2. 对于HTTP与WEB开发之间的关系没有讲解
       3. 没有关于HTTP具体配置的介绍，更像是对rfc的易于理解的表达

  * QUOTE

    #+BEGIN_QUOTE
      * Http request message contains the command and the URI
      * The browser performs one transaction to fetch the HTML "skeleton" that describes the page layout, then issues additional HTTP transactions for each embedded image, graphics pane, Java applet, etc.
      * A "web page" often is a collection of resources, not a single resource.
      * Composite web pages require separate HTTP transactions for each embedded resource.
      * Unlike the start lines and headers, which are textual and structured, the body can contain arbitrary binary data (e.g., images, videos, audio tracks, software applications). Of course, the body can also contain text.
      * TCP/IP hides the peculiarities and foibles of individual networks and hardware, letting computers and works of any type talk together reliably.
      * In TCP, you need the IP address of the server computer and the TCP port number(port number belongs to TCP port) associated with the specific software program running on the server.
      * How do you get the IP address and port number of the HTTP server in the first place? Why, the URI, of course!
      * When the port number is missing from an HTTP URL, you can assume the default value of port 80.
      * Because HTTP uses TCP/IP, and is text-based, as opposed to using some obscure binary format, it is simple to talk directly to a web server.
      * Telnet mimics HTTP clients well but doest't work well as a server. And automated Telnet scripting is no fun at all.
      * HTTP 是不是就是两步交流， 一个request，然后一个response，接下来就没了。
      * We highlights HTTP's role as multimedia transport protocol.
      * Uniform resource locators (URLs) are the standardized names for the Internat's resources. URLs point to pieces of electronic information, telling you where they are located and how to interact with them.
      * URLs are the usual human access point to HTTP and other proctocols: a person points a browser at a URL and behind the scenes, the browser sends the appropriate procotol messages to get the resource that the person wants.
      * The HTTP specification uses the more general concept of URIs as its resource identifiers.
      * URLs can direct you to the resources available through protocols other than HTTP. They can point you to any resource on the Intenet, from a person's email account to files that are available through other protocols, such as the File Transfer Protocol (FTP).
      * With web browsers, you no longer need a news reader to read Internet news  or FTP client to access files on FTP servers. You don't need an eletronic mail program to send and receive email messages. URLs have helped to simplify the online world, by allowing the browser to be smart about how to access and handle resources. Applications can use URLs to simplify access to information.
      * URLs give you and your browser all you need to find a piece of information. They define the particular resource you want, where it is located, and how to get it.
      * Frag: A name for a piece or part of the resource. The frag is not passed to the server when referencing the object; it is used internally by the client. It is separated from the rest of the URL by the "#" character.
      * The scheme is really the main identifier of how to access a given resource. Scheme names are case-insentitive.
      * If HTTP is the Internet's courier, HTTP messages are the packages it uses to move things around.
      * HTTP messages are the blocks of data sent between HTTP applications. These blocks of data begin with some text meta-indomation describing the message contents and meaning, followed by optional data. These messages flow between clients, servers, and proxies. The terms "inbound", "outbound", "upstream", and "downstream" describe message direction.
      * The terms "upstream" and "downstream" related only to the sender and receiver. We can not tell whether a message is heading to the orgin server or the client, because both are downstream.
      * method: THe action that the client wants the server to perform on the resource. It is a singile word, like "GET", "HEAD", or "POST". Request message ask servers to do somethin to a resource. The start line for a request message, or request line, contains a method describing what operation  the server should perform and a request URL describing the resource on wihch to perform the method. The request line also includes an HTTP version which tells the server what dialect of HTTP the client is speaking.
      * Not all servers implement all seven of the methods. Furthermore, because HTTP was designed to be easily extensible, other servers may implement their own request methods in addition to these. These additional methods are called extension methods, because they extend the HTTP specification.
      * As methods tell the server what to do, status codes tell the client what happened. THe numberic code makes error processing easy for programs, while the reason phrase is easily understood by humans.
      * The third part of an HTTP message is the optional entity body. Entity bodies are the payload of HTTP messages. They are the things that HTTP was designed to transport. HTTP messages can carry many kinds of digital data: images, video, HTML, documents, software appplications, credit card transactions, electronic mail, and so on.
      * Accept headers benefit both sides of the connection. Clients get what thet want, and servers don't waste their time and bandwidtih sending something the client can't use.
      * HTTP connections really are nothing more than TCP connections, plus a few rules about how to use them. TCP connections are the reliable connections of the Internet. To send data accurately and quickly, you need to know the basics of TCP. TCP gives HTTP a reliable bit pipe. Bytes stuffed in one side of a TCP connection come out the other side correctly, and in the right order.
      * If you are trying to write sophisticated HTTP applications, and especially if you want them to be fast, you'll want to learn a lot more about the internals and performance of TCP than we discuss in this chaper.
      * Operatng systems provide different facilities for manipulating their TCP connections. Socket API hides all details of TCP and IP from the HTTP programmer. The sockets API was first developed for the Unix operating system, but variants are now available for almost every operating system and language.
      * Common socket interface functions for programming TCP connections.
      * The sockets API lets you create TCP endpoint data structures, connect these endpoints to remote server TCP endpoints, and read and write data streams. The TCP API hides all the details of the underlying network protocol handshaking and the segmentation and reassembly of the TCP data stream to and from IP packets.
      * Becuase the Internet itself does not guarantee reliable packet delivery (Internet routers are free to destroy packets at will if they are overloaded), TCP implements its own acknowledgment scheme to guarantee successful data delivery.
      * Web servers comes in all flavors, shapes, and sizes. There are trivial 10-line Perl script web servers, 50-MB secure commerce engines, and tiny servers-on-a-card. But whatever the functional differences, all web  servers receive HTTP requests for resources and serve content back to the clients.
      * Web servers implement HTTP and the related TCP connection handling. They also manage the resources served by the web server and provide administratice features to configure, control and enhance the web server.
      * Web server appliances are prepackaged software/hardware solutions. The vendor preinstalls a software server onto a vendor-chosen computer platform and preconfigures the software. Some examples of web server appliances include:
          Sun/Cobalt RaQ web appliances
          IBM Whistle web server appliance.
      * All this software is needed to support HTTP/1.1 features: rich resource support, virtual hosting, access control, logging, configuration, monitoring, and performance features. That said, you can create a minimally functional HTTP server in under 30 lins of Perl.
      * State-of-the-art commercial web servers are much more complicated, but they do perform several common tasks, as follows:
        1. Set up connection -- accept a client connection, or close if the client is unwanted.
        2. Receive request -- read an HTTP request message from the network.
        3. Process request -- interpret the request message from the network.
        4. Access resource -- access the resource message and take action.
        5. Construct reponse -- access the resource specified in the message.
        6. Send response -- create the HTTP response message with the right headers.
        7. Log transacton -- place notes about the completed transaction in a log file.
      * When a client request a TCP connection to the web serve, the web server establishes the connection and deternines which client is on the other side of the connection, extracting the IP address from the TCP connection. Once a new connection is established and acceped, the server adds the new connection to its list of existing web server connections and prepares to wathch for data on the connection
      * Different operating systems have different interfaces and data structures for manipulating TCP connections. In Unix environments, the TCP connection is represented by a socket, and the IP address of the client can be found from the socket using the getpeername call.
      * Internal Representations of Message: Some web servers also store the request message in internal data structures that make the message easy to manipulate. For example, the data structure might contain pointeers and lengths of each piece of the request message, and the headers might be stored in a fast lookup table so the specific values of particular headers can be accessed quickly.
      * Many web servers support LF or CRLF as end-of-line sequences, because some clients mistakenly send LF as end-of-line terminator.
      * Web servers constantly watch for new web requests, because requests can arrive at any time. Different web server architectures service requests in different ways:
        1. Single-threaded web servers:
           Single-threaded web servers process one request at a time until completion. When the transaction is complete, the next connection is processed. This architecture is simple to implement, but during processing, all the other connections are ignored. This creates serious performance problems and is appropriate only for low-load servers and diagnostic tools like type-o-server.
        2. Multiprocess and multithreaded web servers
        3. Multiplexed I/O servers
        4. Multiplexed multithreaded web servers
      * Processing Requests:
        Once the web server has received a request, it can process the request using the method, resource, headers, and opthonal body.
        We won't talk about request processing here, because it's the subject of most of the chapters in the rest of this book!
      * Web servers are resource servers. They deliver precreated content, such as HTML pages or JPEG images, as well as dynamic content from resource=generating applications running on the servers. Before the server can deliver content to the client, it needs to identify the source of the content, by mapping the URI from the request message to the proper content or generator on the web server.
      * If a user requests a URL for a directory and the directory contains a file named index.html (or index.htm), the server will return the contents of that file.
      * Dynamic Content Resource Mapping:
        Web servers also can map URIs to dynamic resources -- that is, to programs that generate content on demand. In fact, a whole class of web servers called application servers connect web servers to sophisticated backend applications. The web server need to be able to tell when a resource is a dynamic resource, where the dynamic content generator program is located, and how to run the program. Most web servers provide basic mechanisms to identify and map dynamic resources.
        Apache lets you map URI pathname components into executable program directories. When a server receives a request for a URI with an executable path component, it attempts to execute a program in a corresponding server direcroy. For ecample, the following Apache configuration directive specifies that all URIs whose paths begin with /CGI-BIN/ should execute corresponding programs found in the directory /usr/local/etc/httpd/cgi-programs/:
      * CGI is an early, simple, and popular interface for executing server-side applications. Modern application servers have more powerful and efficent server-side dynamic content support, including Microsoft's Active Server Pages and Java servlets.
      * How Proxies Get Traffic:
        Because clients normally talk directly to web servers, we need to explain how HTTP traffic finds its way to a proxy in the first place. There are four common ways to cause client traffic to get to a proxy:
        1. Modify the client
           Many web clients, including Netscape and Microsoft browsers, support both manual and automated proxy configuration. If a client is configured to use a proxy server, the client sends HTTP requests directly and intentionally to the proxy, instead of to the origin server.
        2. Modify the network
        3. Modify the DNS namespace
        4. Modify the web server
      * Private Caches:
        Private caches don't need much horsepower or storage space, so they can be made small and cheap. Web browers have private caches built right in -- most browers cache popular documents in the disk and memory of your personal computer and allow you to configure the cache size and settings. You also can peek inside the brower caches to see what they contain.
      * Cache Processing Steps
        Modern commercial proxy caches are quite complicated. They are built to be very high-performance and to support advanced features of HTTP and other technologies. But, despite some subtle details, the basic workings of a web cache are mostly simple. A basic cache-processing sequence for an HTTP GET message consists of seven steps :
        1. Receiving -- Cache reads the arriving request message from the network.
        2. Parsing -- Cache parses the message, extracting the URL and headers.
        3. Lookup -- Cache checks if a local copy is available and, if not, fetches a copy (and stores it locally).
        4. Freshness check -- Cache checks if cached copy is fresh enough and, if not, asks server for any updates.
        5. Response creation -- Cache makes a response message with the new headers and cached body.
        6. Sending -- Cache sends the response back to the client over the network.
        7. Logging -- Optionally, cache creates a log file entry describing the transaction.
      * HTTP is becoming a kind of "operating system" for distributed media applications.
      * Client Identification and Cookies
        * Web servers may talk to thousands of different clients simultaneously. There servers often need to keep track of who they are talking to, rather than treating all requests as coming from anonymous clients.
        * The Personal Touch
          HTTP gegin its life as an anonymous, stateless, request/response protocol. A request came from a client, was processed by the server, and a response was sent back to the client. Little information was avaiable to the web server to determine what user sent the request or to keep track of a sequence of requests from the visiting user.
          Modern web sites want to provide a personal touch. They want to know more about users on the other ends of the connections and be able to keep track of those users as they browse. Popular online shopping sites like Amazon.com personalize their sites for you in several ways:
          1. Personal greetings
          2. Targeted recommendations
          3. Administrative information on file
          4. Session tracking
        * To save users from having to log in for each request, most browers will remeber login information for a site and pass in the login information for each request to the site.
      * Digest Authentication:
        * Basic authentication is convenient and flezible but completely insecure. Usernames and passwords are sent in the clear (Usernames and passwords are scrambled using a trivial base-64 encoding, which can be decoded easily. This protects against unintentional accidental viewing but offers no protection against malicious parties), and there is no attempt to protect message from tampering. The only way to use basic authentication securely is to use it in comjunction with SSL.
    #+END_QUOTE

** [[http://igstan.ro/posts/2010-12-01-deriving-the-y-combinator-in-7-easy-steps.html][Deriving the Y Combinator in 7 Easy Steps]]

  * TIME
    1. 2015年01月11日-2015年01月11日

  * COMMENT

  * QUOTE
    #+BEGIN_QUOTE
      * 在没有原生递归支持的语言中，Y结合子 (Y Combinator) 是一种实现递归的方式 （事实上，它更常被作为一种锻炼程序思维的方式）。 要实现Y结合子， 要求这种语言支持匿名函数。
    #+END_QUOTE

** [[www.ccs.neu.edu/home/matthias/BTSS][The Seasoned Schemer]]

  * TIME
    1. 2015年01月08日 - now

  * COMMENT

  * QUOTE
    #+BEGIN_QUOTE
      * 内容是关于list的处理的，所以处理的过程中会使用到各种递归，函数的迭代操作等。当然，如果将这些都弄懂了，就可以在实际编程的过程中进行使用了。
      * We must replace dot with (quote ()), because we are building a list.
      * 我突然清楚了为什么要读"little三部曲"了.
      * Little三部曲，阐述的是recurion算法的思想，而不仅仅是如何操作list，list可以代表当今世界的一切的数据问题(其实现在使用的数据，都比list要简单的多得多得多), 只要能够编写处理list的高级算法，就能够对当今的算法进行汇总。list是对所有数据的抽象，而program就是处理数据的。就像数学是世界的抽象一样，list类似于数学中得数值，而数学方程或者数学证明就如同program中得算法，程序一般。program是一种具体化的数学，都是对现实世界问题提供解决方案的。recursion-data就是list，是对现实世界所有事物最全面深刻的描述， recur 的算法也就是对现实世界事物最好的解决方法。
      * C中的数组，字符串等只是单层的list，根本就没有涉及数据的本质，只是最简单地数据，当然也是现在最容易实现，最普遍使用的数据。要想控制program整个世界，你需要学会这种思想，学会 list 的思想，而不仅仅是单层的for或者iteration。
      * 这才是我学习lisp需要学习的精髓。
      * list的处理，最好的方法就是在list中，处理list，生成list，在自己的代码里面进行迭代处理list，才是最无缝的处理方式。
      * 不同的语言对于编译有不同的理解，不同的编译方式，也就是对于programming language的语义的理解不同。C语言编译器理念，对于编译的理解是单层的，也就是字符串层次上面的，不同的字符串，因为单词的祝贺方式不同，有不同的语义，是对一个层面上的不同的排序方式的模式的识别，是一个层面上的，增加语义，就是增加一种不同的排序方式，然后使用正则文法进行分析，转换成相应地语义，进行计算机的执行。而lisp的理念，是讲语义理解为list，也就是多层次的，语义是可以层层叠加的。不同的语义，是不同的list，对于list的读取，也就是对list的文法的语义的分析，对于list的处理，也就是对list语义的改变；
    #+END_QUOTE






** [[docs.racket-lang.org/web-server/][Web Application in Racket]]

  * TIME

    1. 2015年01月12日 - 2015年01月13日
    2. 2015年01月18日 - 2015年01月21日
    3. 2015年01月24日 - 2015年01月24日
    4. 2015年01月27日 - 2015年01月28日

  * COMMENT

    1. insta
       使用框架，即使是web-server/insta， 就像是写配置文件一样， 没有什么思路， 也就是将所有的文件的配置， 在所谓的代码里面写好， 当然根本不需要去考虑底层是怎么实现的， 只需要去烤炉自己的服务代码怎么实现就可以了。
    2. 配置文件
       一个serve/serlet相当于一个apache的xml的配置文件，只不过是，作为sevlet的参数实现的。serlet的参数可以包括http的各种配置。This sets up and starts a fairly default server instance.
    3. Know the diffrence between Web Server and Servlet.
    4. serve/servlet
       当使用的server只有一个servlet的时候，我们可以使用 serve/servlet 开启一个server，只包含一个servlet，并且包含其他的服务器的配置关键字：
       * #:command-line?
       * #:connection-close:
       * #launch-browser?
       * #:quit?
       * #:banner?
       * #:listen-ip
       * #:port
       * #:max-waiting
       * #:servlet-path
       * #:servlet-regexp
       * #:stateless?
       * #:stuffer
       * #:manager
       * #:servlet-namespace
       * #:server-root-path
       * #:extra-file-paths
       * #:servlets-files-paths
       * #:servlets-root servlets-root
       * #:servlet-current-directory
       * #:file-not-found-responder
       * #:servlet-loading-responder
       * #:servlet-responder
       * #:mime-types-path
       * #:ssl?
       * #:ssl-cert
       * #:ssl-key
       * #:log-file
       * #:log-format
    5. Continuation
       * Continuations are the functional expression of the GOTO statement, and the same caveats apply. While they are a sensible opation in some special cases such as web programming, use of continuations can result in code that is difficult to follow. In fact, the esoteric programming language Unlambda includes call-with-current-continuation as one of its features solely because of its resistance to understanding. The external link
    6. 补充资料
       显然，只看 web server，internal 和 continue 是不够的，因为 racket 的 web server 本来就是含有升级版的 continuation 框架的。
       在学习 web server 编程之前，需要学习关于 continuation，以及 racket web server 相关的几篇论文。（说明 racket web server 是比较学术和科学的。）
    7. 第二遍看完
       web server 其实除了实现了 HTTP 以外，还实现了框架的功能（包括 continuation， template）。 对于其他 API 没有太多的了解。 对于 dispatch， request， response 等。
    8. Servlets
       什么是 servlet？ Servlet 就是一个函数，这个函数，输入的是 request，输出的是response。
       当然，这是基础类型的 servlet， 还有其他更为复杂形势的servlet。
       比如，一个 servlet 根据不同类型的 request， 将这个servlet的输入，分给其他不同servlet，让他们返回response给自己，让自己使用这个response。
       还有的response，可以产生类似于自己的 servlet，当产生一个response给client时，可以使用自己新产生的servlet来服务当前状态的client。
    9. Stateful Servlet
       为每个页面都产生一个相应状态的servlet与之对应。
    10. Stateless Servlet
       将这种对应变成参数，在client和server端进行传递，来确定状态。
    11. Continuation
       Continuation 是一个语言级别的东西，可以实现对于控制流的改变，这是必须的，人的语言不应该这么实现，但是编程语言就应该在基础上，核心上支持控制流的修改。
    12. to learn
       还有很多东西要学，包括，一个 list 里面是如何进行预算的，如何控制 flow 的流动。 control flow 的流动
    13. 2-3章跳过
       我将第2-3两章关于continuation的framework跳过了，原因是自己的racket语言功力尚浅，racket语言包含了很多其他语言没有的先进的programming language的特性。只要学会了rakcet，也就说明语言功底有了基础，现在的话，也自是学习racket的部分功能，使用的racket的功能，也都是和c相同的功能。
    14. 关于 web 的 api 应该差不多
       只有 continuation，这类的和 scheme 这类的 语言相关性的特性, 还有很多不明白的，所以说，c只是最简单的一种语言，也是设计的不合理的语言，组要是为了计算机着想的语言，而schemer才是真正的，programming language。

  * QUOTE

    1. Simple Single Servlet Servers -- serve/servlet
       1. The web-server provides a way quickly configure and start a servlet with more customizability than web-server/insta provides. This is provided by the web-server/servlet-env moudule.
       2. serve/servlet is simpler interface over serve/launch/wait, dispatch/servlet, and a few standard "Dispatcher". Some options, like port and max-waiting are transparently to serve/launch/wait. Some advanced customization requires using these underlying pieces of the web-server directly. However, may simpler customizations do not, which the rest of this section describes.
       3. Servlet and Server
          The servlet is loaded with manager as its continuation manager. (The default manager limits the amount of memory of 64MB and with memory pressure as discussed in the make-threshold-LRU-manager documentation)
          The server files are rooted at server-root-path (which is the distribution root by default.) File Paths, in addation to the "htdocs" directory under server-root-path may be provided with extra-files-paths. These paths are checked first, in the order they appear in the list.
          Other servlets are served from servlets-root. The modules specified by servlet-namespace are shared between servlets found in servlets-root and the current namespace (and therefore the start procedure.)
    2. Stateful Servlets
       1. A stateful servlet should provide the following exports:
          * interface-version
          * manager
          * start
       2. Resonses
          Servlets communicate to the Web Server by returning HTTP response. In order to accommodate lightweight programs (and backwards compatibility), the Web Server provides an indirection from application-specific response formats and the internal HTTP response format, response. can-be-response?, any->response, set-any->response!.
       3. Web Interaction
          The web-server/servlet/web library provides the primary functions of interest for servlet developer.

          * send/back
            sends response to the client. No continuation is captured, so the servlet is done.
          * send/suspend
            captures the current continuation, stores it with exp as the expiration handler, and binds it to a URL. make-response is called with this URL and is expected to generate a can-be-response?, which is sent to the client. If the continuation URL is invoked, the captured continuation is invoked and the request is returned from this call to send/suspend.
          * send/suspend/url
            Like send/suspend but with a URL struct.
          * send/suspend/dispatch
            Calls make-response with a function (often named embed/url) that, when called with a procedure from request? to any/c will generate a URL, that when invoked will call the function with the request? object and return the result to the caller of send/suspend/dispatch. Therefore, if you pass embed/url the identity function, send/suspend/dispatch devolves into send/suspend.
          * send/suspend/url/dispatch
          * send/forward
            Calls clear-continuation-table!, then send/suspend.
          * send/finish
            Calls clear-continuation-table!, then send/back.
          * redirect/get
            Calls send/request with redirect-to, passing hs as the headers.
          * redirect/get/forget
          * current-servlet-continuation-expiration-handler
          * clear-continuation-table!
            Calls the servlet's manager's clear-continuation-table! function. Normally, this deletes all the previously captured continuation.
          * with-errors-to-browser
          * adjust-timeout!
            Calls the servlet's manager's adjust-timeout! function.
          * continuation-url?
            Checks if u is a URL that refers to a continuation, if so returns the instance id, continuation id, and nonce.
          * servlet-prompt
            The tag used for Web interaction continuation capture.
       4. Web Cells
          * The web-server/servlet/web-cells library provides the interface to Web cells. A Web cell is a kind of state defined relative to the frame tree. The frame-tree is a mirror of the user's browsing session. Every time a continuation is invoked, a new frame (called the current frame) is created as a child of the current frame when the continuation was captured.
          * You should use Web cells if you want an effect to be encapsulated in all interactions linked from (in a transitive sense) the HTTP response being generated.
          * web-cell?
          * make-web-cell
          * web-cell-ref
          *
       5. Continuation Managers
    3. Stateless Servlets
       1. A stateless should provide the following exports
          * interface-version
            This indicates that the servlet is a stateless servlet.
          * stuffer
            This is the stuffer that will be used for the servlet
          * manager
            This is the manager that will be used for the servlet
          * start
            This function is called when an instance of this servlet is started. The argument is the HTTP request that initiated the instance.
       2.
    4. HTTP: Hypertext Transfer Protocol
       1. Requests
       2. Bindings
       3. Responses
       4. Placing Cookies
       5. Authenticated Cookies
       6. Extracting Cookies
       7. Redirect
          1. redirect-to
             Generates an HTTP response that redirects the browser to uri, while including the headers in the response.
          2. redirection-status?
             Determines if parameter is one of the following values.
             * permanently
             * temporarily
             * see-other
       8. Basic Authentication
          1. make-basic-auth-header
          2. request->basic-credentials
       9. Digest Authentication
          1. make-digest-auth-header
          2. request->digest-credentials
          3. username*realm->password/c
          4. username*realm->digest-HA1/c
          5. password->digest-HA1
          6. make-check-digest-credentials
       10. X-expression Support
           1. response/xexpr
              This is a viable function to pass to set-any->response!
    5. URL-Based Dispatch : (require web-server/dispatch)
       1. Using web-server/dispatch
       2. APIs
       3. Imperative Dispatch Containers
       4. Built-in URL patterns
       5. Extending web-server/dispatch
    6. Formlets: Functional Form Abstraction
    7. Servlets communicate to Web Server by returing HTTP responses.

** [[http://www-verimag.imag.fr/~plafourc/teaching/latex.pdf][LaTeX: A Document Preparation System]]

  * TIME

    1. 2015年01月14日 - 2015年01月14日

  * COMMENT

  * QUOTE

    1. File types: Normal LaTeX files (".tex" extension)
    2. style files (".sty" extension)
    3. style documentation files (".doc" extension)
    4. auxilary files (".aux" extension)
    5. table of contents files (".toc" extension)
    6. list of tables files (".lot" extension)
    7. list of figures files (".lof" extension)

** [[http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html][SSL/TLS协议运行机制的概述]]

  * TIME

    1. 2015年01月16日 - 2015年01月16日

  * COMMENT


  * QUOTE








** [[http://docs.racket-lang.org/web-server-internal/index.html][Web Server: HTTP Server]]

  * TIME

    1. 2015年01月18日 - 2015年01月18日
    2. 2015年01月28日 - 2015年01月28日

  * COMMENT

    1. 看第一遍的时候，发现大部分函数还是能够看懂的，但是有些racket特有的语法没有看懂，比如协议，比如函数名后缀的含义等，或许可以将rakcet web 实现源码通读，加深理解。
    2. 对于Racket Web API同其他语言API的对比
    3. 各个部分之间的关系，如何结合？ 是只能通过servlet还是怎样？
    4. web-server 下面有 serve/servlet 也就是使用这个函数，作为整个web app的出发点，也就是以一个添加各种参数以及一个servlet的函数是整个server的出发点。
    5. serlet 执行的条件是符合servlet的模式识别


  * QUOTE
    1. start is loaded as a servlet and responds to requests that match servlet-regexp. The current directory of serlet execution is servlet-current-directory.


** [[dl.acm.org/ccs/cfm][The ACM Computing Classification System]]

  * TIME

    1. 2015年01月19日 - 2015年01月19日

  * COMMENT

    1. Computer CLassification System
       * 对大致的计算机领域进行分类，可以扩展自己对计算机领域的大致了解

  * QUOTE

    1. General and Reference
       1. Document types
          1. Surveys and overviews
          2. Reference works
          3. General conference proceedings
          4. Biographies
          5. General literature
          6. Computing Standards, RFCs and guidelines
       2. Cross-computing tools and techniques
          1. Reliability
          2. Empirical studies
          3. Measurement
          4. Metrics
          5. Evaluation
          6. Experimentation
          7. Estimation
          8. Design
          9. Performance
          10. Validation
          11. Verification
    2. Hardware
       1. Printed circuit boards
       2. Communication hardware, interfaces and storage
       3. Integrated circuits
       4. Very large scale integration design
       5. Power and energy
       6. Electronic design automation
       7. Hardware validation
       8. Hardware test
       9. Robustness
       10. Emerging technologies
    3. Computer Systems Organization
       1. Architectures
          1. Serial architectures
          2. Parallel architectures
          3. Distributed architectures
          4. Other architectures
       2. Embedded and cyber-physical systems
          1. Sensor networks
          2. Robotics
          3. Sensors and acuators
          4. System on a chip
          5. Embedded system
       3. Real-time systems
          1. Real-time operating systems
          2. Real-time languages
          3. Real-time system specification
          4. Real-time system architecture
       4. Dependable and fault-tolerant systems and networks
          1. Reliability
          2. Availability
          3. Maintainability and maintenance
          4. Processors and memory architecures
          5. Secondary storage organization
          6. Redundancy
          7. Fault-tolerant network topologies
    4. NetWorks
       1. Network architectures
       2. Network protocols
       3. Network components
       4. Network algorithms
       5. Network performance evaluation
       6. Network properties
       7. Network services
       8. Network types
    5. Software and its Engineering
       1. Software organization and properties
          1. Contextual software domains
          2. Software system structures
          3. Software functional properties
          4. Extra-functional properties
       2. Software notations and tools
          1. General programming language
          2. Formal language definitions
          3. Compilers
          4. Context specific languages
          5. System description languages
          6. Development frameworks and environments
          7. Software configuration management and version control systems
          8. Software libraries and responsitories
          9. Softwaremaintenace tools
       3. Software creation and management
          1. Design Software
          2. Software development process management
          3. Software development techniques
          4. Software verification and valiation
          5. Sottware post-development issuses
          6. Collaboration in software development
          7. Search-based software engineering
    6. Theory of Computation
       1. Models of computation
          1. Computability
             1. Lambda calculus
             2. Turing machines
             3. Recursive functions
          2. Probabilistic computation
          3. Quantuum computation theory
          4. Interactive computation
          5. Streamning models
          6. Concurrency
          7. Timed and hybrid models
          8. Abstract machines
       2. Formal languages and automata theory
       3. Computational complexity and cryptography
       4. Logic
       5. Design and analysis of algorithms
       6. Randomness, geometry and discrete structures
       7. Theory and algorithms for application domains
       8. Semantics and reasioning
    7. Mathematics of Computing
       1. Discrete mathematics
       2. Probability and statistics
       3. Mathematical software
       4. Information theory
       5. Mathematical analysis
       6. Continuous mathematics
    8. Informatoin Systems
       1. Data management systems
       2. Information storage systems
       3. Information systems applications
       4. World Wide Web
       5. Information retrieval
    9. Security and Privacy
       1. Crytography
       2. Formal methods and theory of security
       3. Security services
       4. Intrusion/anolmaly detection and malware mitigation
       5. Security in hardware
       6. Systems security
       7. Network security
       8. Database and storage security
       9. Software and application security
       10. Human and societal aspects of security and privacy
    10. Human-centered Computing
        1. Human computer Interaction (HCI)
        2. Interaction design
        3. Collaborative and social computing
        4. Ubiquitous and mobile computing
        5. Visualization
        6. Accessibility
    11. Computing Methodologies
        1. Symbolic and algebraic manipulation
        2. Parallel computing methodologies
        3. Artificial intelligence
        4. Machine learning
        5. Modeling and simulation
        6. Computer graphics
        7. Distributed computing methodologies
        8. Concurrent computing methodologies
    12. Applied Computing
        1. Electronic commerce
        2. Enterprise computing
        3. Physical science and engineering
        4. Life and medical science
        5. Law, social and behavioral science
        6. Computer forensics
        7. Arts and humanities
        8. Computers in other domains
        9. Operations research
        10. Education
        11. Document management and text processing
    13. Social and Professional Topics
        1. Professional topics
        2. Computing / technology policy
        3. User characteristics
    14. Proper Nouns: People, Technologies, and Companies
        1. Companies
        2. Organizations
        3. People in computing
        4. Technologies

** [[http://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/paper.pdf][Implementation and Use of the PLT Scheme Web Server]]

  * TIME

    1. 2015年01月20日 - 2015年01月20日

  * COMMENT

    1. HTTP -> Web
       HTTP 是指的交流，无状态的交流
       Web 是建立在这种交流上的应用
       Web 不知道每次过来的每个请求是谁的，但是应用又是并不仅仅是获取信息，还有各种复杂的需求，需要在这种无状态的通信上实现
       从 HTTP 到 Web，需要突破解决各种问题，包括 client 和 server 交互的多种状态，多个 client 和 一个 server 之间的交互， client 进行多种随意性操作。
       这需要各种工程性的积累，包括 MVC 框架，包括各种库
       HTTP 和 Web 这之间有一堵墙，或者是有一条河，必须穿越过去，才能很好地理解 Web Programming.


  * QUOTE

    1. Why do Web applications depend on Web presence?
       Why do Web applications, even those built by corporations that depend heavily on their Web presence, hehave thus? Two factors complicate the development of Web software relative to traditional console software. The first is the Web browser gives users the ability to traverse a web of interaction through the use of back and forward buttons, window cloning operations, and so on. The second is that, for scalability, the Web is built atop a stateless interface, which complicates the structure of interactive Web software.
    2. A web server provides operating system-style services.
       Like an operating system, a server runs programs (namely servlets). Like an operating system, a server should protect these programs from each other. And like an operating system, a server manages resources (such as network connections) for the programs it runs. Most existing Web servers rely on the underlying operating system to implement these services: they create a fresh OS process for each incoming request which necessitates the creation of a new address space, loading code and so on. The PLT Scheme Web Server instead uses user-level threads, and relies on the operating system-like facilities provided by the underlying language to offer protection to individual servlet instances (as discussed in section 2.6). For these two reasons, we should expect higher performance from our Web server than from conventional servers that use CGI.

** [[Http://pagesperso-systeme.lip6.fr/Christian.Queinnec/PDF/webcont.pdf][The influence of Browsers on Evaluators or, Continuation to Program Web Servers]]

  * TIME

    1. 2015年01月20日 - 2015年01月20日

  * COMMENT

  * QUOTE

** [[http://docs.racket-lang.org/continue/index.html][Continue: Web Applications in Racket]]


  * TIME

    1. 2015年01月21日 - 2015年01月23日

  * COMMENT

    1. 使用 HTTP 和使用 SQL Data Base 有共同的特点，就是可以使用一定的规则，对于不是该语言处理范围内容的东西，进行传递。
    2. what's servlet
       不要对 servlet 有任何的陌生感，其实servlet和 c-lang 中得 main 函数没有任何的不同。 只不过是编译环境变了， standard API 变了。 其实，一个软件，不也就是操作系统上的一个 servlet 么？

  * QUOTE

    1. send/suspend/dispatch
       Let's look more closely at the send/suspend/dispatch mechanism. send/suspend/dispatch consumes a response-generating function and give it another function, called embed/url, that we will use to build special URLs. What makes these URLs special is this: when a web browser visits one of them, our web application restarts, not from start, but from the handler that we associate with the URL.
    2. handlers
       We can be even more sophisticated about the handlers associated with embed/url. Because a handler is just a request-consuming function, it can be defined within a local and so can see all the other variables in the scope of its definition.
    3. mutable
       By default, structures in Racket are immutable. To gain access to structure mutators, we'll need to override this default, by adding the #:mutable keyword to some of our structure definiations.
       A mutable structure provides functions that change its fields; in this case, we are provided the structure mutator set-blog-posts!, which allows us to change the posts of a blog.
       Now, when you visit the blog from two seperate browser windows and add posts from each of them. You'll be glad to see that both windows share the same blog.
    4. prefab
    5. Using an SQL database
    6. Using Formlets
       The Racket Web framework provides formlets to abstract these names away, by adjusting them automatically in the HTML, and by presenting the following interface for the display and processing of forms.
    7. Leaving DrRacket
       We've been in the habit of pressing the Run button to run our application in DrRacket. But if we were actually to deploy an application, we'd need to launch it by a different method.
       The simplest alternatives is to use web-server/servlet-env.

** [[http://docs.racket-lang.org/more/][More: Systems Programming with Racket]]

  * TIME

    1. 2015年01月23日 - 2015年01月23日

  * COMMENT

  * QUOTE

    1. Subject
       Underneath the facade of DrRacket lies a sophisticated toolbox for managing threads and processes, which is the subject of this tutorial.
       Specifically, we show how to build a secure, multi-threaded, serlet-extansible, continuation-based web server.
    2. "Hello World" Server
       1. serve
          We'll implement the web server through a serve functino that takes an IP port number for client connection.
          The server accepts TCP connections through a listener, which we create with tcp-listen. To make interactive development easier, we supply #t as the third argument to tcp-listen, which lets use re-use the port immediately, without waiting for a TCP timeout.
    3. Server Thread
    4. Terminating Connections
       A malicious client could connect to our web server and not send the HTTP header, in which case a connection thread will idle forever, waiting for the end of the header. To avoid this possibility, we'd like to implement a timeout for each connection thread.
    5. Dispatch
       To parse the incoming URL and to more easily format HTML output, we'll require two extract libraries: (rquire xml net/url)
    6. Limiting Memory Use
       With our latest "many" servlet, we seem to have a new problem: a malicious client could request so many "hello"s that the serve runs out of memory. Actually, a malicious client could also supply an HTTP request whose first line is arbitrarily long.
       The solution to this class of problems is to limit the memory use of a connection.
    7. Continuation
       As a system example, the problem of implementing a web server exposes many system and security issues where a programming language can help. The web-server example also lead to a classic, advanced Racket topic: continuations. In fact, this facet of a web server need delimited continuations, which Racket provides.
       The problem solved by continuation is related to servlet sessions and user input, where a computation spans multiplea client connections. Often, client-side computation (as in AJAX) is the right solution to the problem, but many problems are best solved with a mixture of techniques (e.g., to take advantage of the brower's "back" button).
       As the multi-connection computation becomes more complex, propagating arguments through query becomes inscreasing tedious.
       Continuation let us implement a send/suspend operation that performs exactly that operation. The send/suspend procedure generates a URL that represents the current connect's computation, capturingit as a continuation. It passes the generated URL to a procedure that creates the query page; this query page is used as the result of the current connection, and the surrounding computation (i.e., the continuation) is aborted. Finally, send/suspend arranges for a request to the generated URL (in a new connection) to restore teh aborted computation.







** [[docs.racket-lang.org/xrepl][XREPL: eXtended REPL]]

  * TIME

    1. 2015年01月23日 - 2015年01月23日

  * COMMENT

  * QUOTE

    * xrepl-lib
      Loading the xrepl library enables XREPL, which extands the racket REPL significantly, turning it into a more useful tool for interactive exploration and development. Additions include "meta commands," using readline, keeping past evaluation results, and more.
    * Meta REPL Commands
      * Sum
        Most  of the XREPL extensions are implemented as meta commands. These commands are entered at the REPL, prefixed by a , and followed by the command name. Note that several commands correspond directly to Racket functions (e.g., ,exit) -- but since they work outside of your REPL, they can be used even if the matching bindings are not available.
      * Generic Commands
        1. ,help
           display available commands
        2. ,exit
           exit racket
        3. cd
           change the current directory
        4. ,pwd
           display the current directory
        5. ,shell / ,sh
           Use ,shell (or ,sh) to run a generic shell command (via system). For convenience, a few synonyms are provided -- they run the specified executables (still using the system).
        6. ,edit
           edit files in your $EDITOR
      * Binding Information
        1. ,apropos / ,ap
           Searches for known bindings in the current namespace.
        2. ,describe / ,desc / ,id
           For each of the specific names, describe where it is coming from and how it was defined if it names a known binding. In addition, describe the module (list its imports and exports) that is named by arguments that are known module names.
           By default, bindings are searched for at the runtime level (phase 0). You can add a different phase level for identifier lookups as a first argument. In this case, only a binding can be described, even if the same name is a known mudule.
        3. ,doc
           browser the racket documentation
      * Requiring and Loading Files
        1. ,requre / ,req / ,r
           require a module
        2. ,require-reloadble
           require a module, make it reloadable
           Same as ,require, but arranges to load the code in a way that makes it possible to reload it later, or if a module was already load (using this command) then reload it.
        3. ,enter / ,en
           Requre a module and go into its namespace
        4. ,toplevel / ,top
           Go back to the toplevel
        5. ,load / ,ld
           Load a file
      * Deguging
        1. ,backtrace / ,bt
           See a backtrace of the last exception
           Whenever an error is diaplayed, XREPL will not show its context printout. Instead, use the ,backtrace command to diaplay the backtrace for the last error.
        2. ,time
           Time an expression.
           Times execution of an expression (expressions). This is similar to "time" but the information that is dispalyed is a bit easier to read.
        3. ,trace / ,tr
           trace a function
        4. ,untrace / ,untr
           untrace a function
      * Miscellaneous Commands
        1. ,switch-namespace / ,switch
           Switch to different repl namespace.
           This powerful command controls the REPL's namespace. While ,enter can be used to make REPL go into the namespace of a specific module, the ,switch-namesapce command can switch between toplevel namesapces, allowing you to get multiple separate "workspaces".
    * Past Evaluation Results
    * Hacking XREPL
      1. Sum
         XREPL is mainly a convenience tool, and as such you might want to hack it to better suit your needs. Currently, there is no convient way to customize and extend it, but this will be added in the future.
         While this is not intended as the way to extend and customize XREPL, it is a useful debugging tool should you want to do so.

** [[docs.racket-lang.org/reference/][The Racket Reference]]

  * TIME

    1. 2015年01月23日 - Continue

  * COMMENT

    1. 学习计算机包含了很多东西，就拿racket来说，学深了可以涉及到 OS，亦或者 language。 学工程了，就会涉及到 Internet TCP/IP等。 真是不是几个星期几个月就可以搞 定的。 一定要多方面的学习，才能掌握 CS 的基础。 在出国以前，这一定要形成。
    2. What exactly is tail position for recur?
       The tail position is a position which an expression would return a value from. There are no more forms evaluated after the form in the tail position is evaluated.

  * QOUTE

    1. Language Model

       1. Evaluation Model

          Racket evaluation can be viewed as the simplification of expression to obtain values.

          1. Sub-expression and Continuation

             * Some simplifications require more than one step.
             * An expression that is not a value always be partioned into two parts: a redex, which is the part that changed in a single-step simplification, and the continuation, which is the evaluation context surrounding an expression. That is, the continuation says how to "continue" after the redex is reduced to a value.
             * Before some things can be evaluated, some sub-expressions must be evaluated; for example, in the application (- 4 (+ 1 1)), the application of - can not be reduced until the sub-expression (+ 1 1) is reduced.
             * Thus, the specification of each syntactic form specifies how (some of) sub-expressions are evaluated, and then how the results are combined to reduced the form away.
             * The dynamic extent of an expression is the sequence of evaluation steps during which the expression contains the redex.

          2. Tail Position

             * An expression expr1 is in tail position with respect to an enclosing expression expr2: if whenever expr1 becomes a redex, its continuation is the same as was the enclosing expr2's continuation
             * Tail-position specificatons provides a guarantee about the asymptotic space consumption of a computation. In general, the specification of tail positions goes with wach syntatic form, like if.

          3. Multiple Return Values

             * A Racket expression can evaluate to multiple values, in the same way that a procedure can accept multiple arguments.
             * Most continuations expect a particular number of result values.
             * In general, the specification of a syntactic form indicates the number of values that produces and the number that it expects from each of its sub-expression. In addition, some procedures (notably values) produce multiple values, and some procedures (notably call-with-values) create continuations internalllly that accept a certain number of values.

          4. Top-Level Variables

             * A set of top-level variables are available for substitutions on demand during evaluation.
             * In Racket, the way definitions appear is just as important as the way that they are used.
             * Racket evaluation thus keeps track of both definitions and the current expression, and it extends the sets of definitions in response to evaluating forms such as define.
             * Each evaluation step, then, takes the current set of definitions and program to a new set of definitions and program.
             * Before a define can be moved into the set of definitions, its right-hand expression must be reduced to a value.
             * Using set!, a program can change the value associated with an existing top-level variable.
             * Using set!, a program can change the value associated with an existing top-level variable.
               Change the VALUE associated with an EXISTING TOP-LEVEL VARIABLE.

          5. Objects and Imperative Update

             1. In addition to set! for IMPERATIVE UPDATE of top-level variables, various procedures enable the modification of ELEMENTs within a compound data structure. For example, vector-set! modifies the content of a vector.
             2. To allow such modification to data, we must distinguish between values, which are the results of expressions, and objects, which hold the data reference by a value.
             3. A few kinds of objects can server directly as values, including booleans, (void), and small exact integers.
             4. More generally, a value is a reference to an object. For example, a value can be a reference to a particular vector that currently holds the value 10 in its first slot. If an object is modified, then the modification is visible through all copies of the value that reference tha same object.
             5. In the evaluation model, a set of objects must be carried  along with each step in evaluation, just like the definition set.
             6. The distinction between a top-level variable and an object reference is crucial. A topic-level variable is not a value; each time a variable expression is evaluated, the value is extracted from the current set of definitions.
             7. An object reference in contrast is a value, and therefore needs no further evaluation.
             8. The model evaluation steps above use angle-bracketd <> for an object reference to distinguish it from a variable name.
             9. A direct object reference can never appear in a text-based source program. A program representation with datum->syntax, however, can embed direct references to existing onjects.

          6.

    2. Datatypes

       1. Booleans and Equlity
       2. Numbers
       3. String?
       4. Byte Strings
       5. Characters
       6. Symbols
       7. Regular Expresson
       8. Keywords
       9. Pairs and Lists
       10. Mutable Pairs and Lists
       11. Vectors
       12. Boxes
       13. Hash Tables

       14. Sequences and Streams
           Sequences and streams abstract over iteration of elements in a collection. Sequences allow iteration with for macros or with sequence operations such as sequence-map. Streams are functional sequences that can be used either in a general way or a stream-specific way. Generators are closely related stateful objects that can be converted to a sequence and vice-versa.

           1. Sequences
              A sequence encapsulates an ordered collection of values. The elements of a sequence can be extracted with one of the for syntax forms, with the procedures returned by sequence-generate, or by converting the sequence into a stream.



           2. Streams

           3. Generators

       15. Dictionaries
       16. Sets
       17. Procedures
       18. Void
       19. Undefined






** [[docs.racket-lang.org/json][JSON in Racket]]

  * TIME

    2015年01月24日 - 2015年01月24日

  * COMMENT

    1. Json 把它理解成是 js 中一种 struct 就可以， 其实本来就是。 为了让后端的各种语言，将数据传递到前端的 JS 上面。

  * QUOTE

    1. JSON
       JavaScript Object Notation (JSON) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language.

    2. JS-Expression - jsexpr
       Some names in this library use “jsexpr” and some use “json”. The rationale that the first is used for our representation, and the second is used as information that is received from or sent to the outside world.

** [[http://planet.racket-lang.org/package-source/jaymccarthy/mongodb.plt/1/4/planet-docs/mongodb/][MongoDB in Racket]]

  * TIME

    1. 2015年01月24日 - 2015年01月24日

  * COMMENT

    1. 看 MongoDB 看多了，就会想着去查看 MongoDB 更多的功能，然后想着去实现 MongoDB 需要什么？ 然后就会去看 DB 的实现， nosql 的实现。
    2. MongoDB 也是一个server，也是一个 网络服务，和 web 服务没有什么不同，最大的不同就是他已经全部编辑好的一个实用的软件，而不是一个需要构件的容器。
    3. 软件之间进行交互，不仅仅可以通过 脚本文件，通过 操作系统 中的调用，还可以通过 localhost 中的 port 使用 网络数据交互的方式进行交互。当然也是通过 OS 的 套接字编程实现的。
    4. 自己对 language 本身自带的数据结构 data structure ( hash dict list verctor) 还没有搞明白就像编代码。。。 本来就是想要使用电脑操纵数据，现在你连数据格 式都不会。
    5. ORM
       因为在对 MongoDB 的基础操作中，要对 find 出来得 cursor 一个一个进行处理，然后收工形成一个 sequence，在使用 ORM 的时候，就可以直接得到一个 find 的 sequence。

  * QUOTE

** [[http://pkg-build.racket-lang.org/doc/pkg][Package Management in Racket]]

  * TIME

    1. 2015年01月24日 - 2015年01月24日

  * COMMENT

  * QOUTE

** [[mitpress.mit.edu/scip][Structure and Interpretation of Computer Programs]]

  * TIME

    1. 2015年01月28日 - CONTINUE

  * COMMNET

  * QUOTE

** 暗时间

  * TIME

    1. 2015年02月20日 - 2015年02月26日

  * COMMENT

    1. 对于经验知识
       要讲这些知识，设身处地的变成自己经历的知识，这样既能很好的理解和吸收知识，又能节约探索知识的时间。将自己的情绪与这些不属于自己经历获得的知识联系起来，更好的吸收。

    2. 虚拟实践与实际实践
       将别人的时间，设身处地的变成自己的时间的过程为“虚拟实践”。 很多时候，你没办法遍历人生的每条路径，去看看会发生什么，你没有这样的时间资源，取而代之的是，你只能通过别人的“替代经验”，自己的“虚拟经历”，来获得尽量多的信息。

    3. 理性的筛选信息
       观察，阅读，并别忘了带着你的理性去审视（包括文本），弄清娱乐是娱乐，知识是知识。如果你行真正的得到一些知识，最好过滤一下你的信息。否则你只能在别人的思考中得意。

  * QUOTE

    1. 主动关注和被动关注
       把主动关注放到重要的事情上，被动关注，让那些琐碎的事情来找你，被动的接受这些事情。

    2. 获取的多少
       获得的多少并不取决于读了多少，而是取决于思考了多少，多深。

    3. Essential and non-essential knowledge
       对于程序员来说，硬件体系结构，操作系统的实现机制，主流编程范式是为了满足什么需求出现的 都是essential的。

    4. 自利归因
       归结于客观原因，推卸自己的责任。一旦你说出“这件事不是我的原因”这样的话之后，除了心里好受了之外，你也开始相信这件事情的失败真的与你无关，你自己这方面不需要做任何改变（因为你觉得不是你的问题），于是结果你下次同样也不回成功。增大成功的几率，本来就是我们付出的时间的原因。我们每个人内心的观念都会对我们看待周围的事物起一个滤镜的作用，过滤一切所见之物。扭曲它们以使它们符合我们内心的主观意识。

** 黑客

  * TIME

    1. 2015年02月21日 - 2015年02月24日

  * COMMENT

    1. 我对计算机从电气学的大树干中，分离出来，开宗立派过程的理解。对计算机由大型机转换到微型机，然后，有硬件核心到软件核心，由专业领域面向到娱乐游戏领域的转变。

  * QUOTE

** 浪潮之巅

  * TIME

    1. 2015年02月24日 - 2015年02月26日

  * COMMENT

  * QUOTE

** 编码：隐匿在计算机软硬件背后的语言

  * TIME

    1. 2015年02月26日 - 2015年03月01日

  * COMMENT

  * QUOTE







-----








* PLT

** [[www.dreamsongs.com/Files/HOPL2-Uncut.pdf][Evolution of Lisp]]
  * To be read
  #+BEGIN_QUOTE
  *
  #+END_QUOTE

** [[www.ccs.neu.edu/home/matthias/BRS][The Reasoned Schemer]]
  * Time Line
  * to read

** Compiling with Continuations

   [[http://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X][Info]]
   - State :: To read
** [[www.eopl3.com][Essentials of Programming Languages]]

  * TIME
  * COMMENT
  * QUOTE

* Web

** [[http://shop.oreilly.com/product/9780596805838.do][REST in Practice]]

  * TIME

  * COMMENT

  * QUOTE


** [[http://shop.oreilly.com/product/9780596529260.do][RESTful Web Services]]

  * TIME
  * COMMENT
  * QUOTE
* Tech

** [[http://www.amazon.com/Out-Control-Biology-Machines-Economic/dp/0201483408][Out of Control: The New Biology of Biology of Machines, Social Systems, and the Economic World]]
  * 2015年01月15日 - now
