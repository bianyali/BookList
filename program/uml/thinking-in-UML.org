#+TITLE:         Thinking in UML
#+AUTHOR:        Yali Bian
#+DATE:          2015-08-18 Tue


* 1 为什么需要 UML

** 1.1 面向过程还是面向对象

  人们很快发现了问题：编程需要的对象，不但不能够从设计中自然地推导出来.
  而且 强调连续性和过程化的结构化设计 与 事件驱动型的离散对象结构 之间有着难以调和的矛盾。

** 1.2 UML 带来了什么

*** 可视化

    把那些通过文字很难表达清楚的，隐晦的潜台词用简单直观的图形表达出来，准确直观地描述复杂地含义。

    一段描述汽车车窗，方向盘之类地话，看起来很简单，这是因为汽车是我们熟悉地事务。 如果一个不知道汽车地人，靠这段描述去设计一辆汽车地话，一定觉得缺少了很多信息。

    如果信息点比较多，而且相互之间有关系，阅读文字并不容易了解到到底叙述了怎么样地一个逻辑结构。 如果是面向更加复杂地业务需求时，书写或阅读长达几十页地文字，要把所有地信息都关联起来，并且准确地理解，就更加困难了。

    用文字来表达风花雪月是很美地，朦胧美，想象美。 但是要用来说明一个结构，是不太容易地。

    逻辑结构，相互之间关联比较多的话，更好的是用 图形 来表达。

*** RUP

    UML 是一种语言，用来描述软件生产过程中要产生的可视化形式的文档
    指导 programmer 去开发software。
    RUP 是指导如何产生这些文档以及这些文档要讲述什么样的方法。

* 2 建模基础

** 2.1 建模

** 2.2 用例驱动

** 2.3 抽象层次

** 2.4 视图

   视图是人们观察事物的角度。

   恰当的视角可以让观察者更容易的抓住信息的本质。

** 2.5 对象分析方法

* 3 UML 核心元素

** 3.1 版型 － steretype

   这个概念是对 UML 元素基础定义的扩展，在同一个元素基础定义的基础上，赋予特别的含义，使得这个元素适用于特定的场合。

   类的版型有：接口，边界类，实体类，控制类。

   版型可以自定义。

** 3.2 参与者 - actor

*** 基本概念

    参与者（actor）在建模过程中处于核心地位。 actor 是在系统之外与系统交互的某人或某事物。

    柜台职员也参与了业务，但是他们是“业务工人”.

    参与者可以非人： 有些需求并没有人参与，参与者如何确定？

*** 发现参与者

*** 业务主角 － business actor

    业务主角是参与者的一个版型，特别用于定义业务的参与者，在需求阶段使用。 业务主角是与业务系统有着交互的人和事物，他们用来确定业务范围。

*** 业务工人

    没有完整的业务目标，系统不是为他服务的，不是主动的向系统发出动作的。

*** 参与者与涉众的关系

    涉众－stackholder,也称为干系人。

    作为涉众，投资方的一件或许会构成一些约束。
    但是投资方并不会参与系统的建设，它只是从资本拥有这个系统并从将来的收入中获得回报。

*** 参与者和用户的关系

    用户－User 是指系统的使用者，通俗一点就是系统的操作员。
    用户是参与者的代表，或者说是参与者的实例或代理。

    并非所有的参与者都是用户，但是一个用户可以代理多个参与者。

*** 参与者和角色的关系

    角色－Role 是参与者的职责。

    角色是一个抽象的概念，从众多参与者的职责中，抽象出相同的那部分，将其命名而形成一个角色。 一个角色代表系统中的一类职责。

*** 参与者的核心地位

*** 检查点

** 3.3 用例 － Use Case

   用例在 UML 建模中，是最重要的一个元素。因为 UML 是面向对象的，除了用例，其他所有元素都是“封装的”，“独立的”。

*** 基本概念

   Use Case（用例）是一个UML中非常重要的概念，在使用UML的整个软件开发过程中，Use Case处于一个中心地位。
   用例是对一组动作序列的抽象描述，系统执行这些动作序列，产生相应的结果。这些结果要么反馈给参与者，要么作为其他用例的参数。

   用例定义了一组用例实例，其中每个实例都是系统所执行的一系列操作，这些操作生成特定主角可以观测的值。

   一个用例就是与参与者交互的，并且提供参与者可观测的有意义的结果，的一系列的活动的集合。

*** 用例的特征

    用例有着一系列的特征。 这些特征保证能够正确的捕捉功能性需求，同时这些特征也是判断用例是否准确的依据。

    * 用例是相对独立的
    * 用例的执行结果对参与者来说是可观测的，有意义的
      登陆系统是一个有效的用例，但输入密码却不是。
    * 事情是由一个参与者发起的，不存在没有参与者的用例，用例不应该自动启动。
      也不应该主动启动另一个用例
    * 用例必然是以动宾短语形式出现的
      用例必须有一个动作和动作的受体
    * 一个用例就是一个需求单元，分析单元，设计单元，开发单元，测试单元，甚至部署单元。
      一旦决定了用例，软件开发工作的其他活动都以这个用例为基础，围绕他进行。

*** 用例的粒度

    到底一个大的用例合适，还是分解成多个小用例合适呢？

    在业务建模阶段，用例的粒度以每个用例能够说明一件完整的事情为宜。
    即一个用例可以描述一项完整的业务流程。这将有助于明确需求范围。

    在用例分析阶段，即概念建模阶段，用例的粒度以每个用例能描述一个完整的事件流为宜。
    一个用例描述一项完整业务中的一个步骤。
    采用一些面向对象的方法，归纳和抽象出业务用例的关键概念模型，并为之建模

*** 用例的获得

    用例的定义就是由参与者驱动的，并且给参与者提供可观测的有意义的结果的一系列活动，用例的来源就是参与者对系统的期望。

    发现用例的前提条件是发现参与者，而确定参与者的同时就确定了系统边界。

*** 用例和功能的误区

    在实际应用中，用例是非常容易被误解和误用的。 尤其是习惯了面向过程结构化设计方法的计算机技术人员。
    最普遍的误解就是认为用例就是功能的划分和描述。他们认为一个用例就是一个功能点。
    在这种理解下，用例建模变成了仅仅是较早前需求分析方法中的功能框图的翻版。

    功能实际描述的是输入->计算->输出。DFD图？这可是典型的main 香过程分
    析模式。因此将用例当作功能点的做法实际是在做面向过程的分析。

    面向对象是合理的，以为，面向对象，更加突出的引导大家，将一系列同等事物的功能放到一起，是一个知识积累的过程，相反，面向过程，这是想着，要用到什么，我们就积累什么信息，下次使用，再定义一个类似的信息。 而真正的实践性的面向对象，应该是这个样子的，对象用来存储知识，是一个横向的积累的过程，面向过程是用来应用的，将存储的信息拿出来使用的，进行应用的过程。就如同 UML 中的 对象 和 用例 的关系一样。还如同 js 中的包一样，使用的时候，就是将一个系统的功能放到一个函数中，让这个函数作为接口来实现所有的功能。

    将工程分成两个横截面：
      － 面向知识储备，对应用系统的深入的模块的理解  -> 面向对象：面向模块
      － 面向应用，面向用户，提供接口，将系统积累的强大功能，通过串联使用各个知识部分，通过简洁有效的手段曝露给用户 -> 面向过程，面向命令式

    面向过程，和面向对象的另一个区别： 面向对象在设计的时候，就是按照 模块，实际的知识积累分开的
    面向过程，是在应用过程中，将需要共同使用的东西，共同筹划的东西，抽象出来，形成模块。

*** 业务用例 - business use case

    业务用例是用例版型的一种，专门用于需求阶段的业务建模。
    在为业务领域建立模型时，应该使用这种版型。
    请注意，业务用噢知识普通用例的一个版型，并不是一个新的概念，因此业务用例具有普通用例的所有特征。

*** 概念用例 - conception use case

*** 系统用例

*** 用例实现

** 3.4 边界

   边界本质上时面向对象的一个很重要的概念，与封装的概念同源。

   面向对象里，任何一个对象都有一个边界，外界只能通过这个边界来认识对象，和对象打交道，而面向对象能不是一个进去。

   我们把边界放大了看，对于世界上的任何东西，我们都不能完全掌握他的本质，只能通过它的行为，外观，性质来描述它。 行为也好，外观也吧，这就是这个东西的一个边界，我们就是通过这些边界来认识事物的。

*** 边界决定抽象层次

    自顶向下的方式： 通过缩小边界进而影响到我们可以观察到的事物，这就决定了我们的抽象层次，使得我们的分析可以有条不紊地地进行细化。

    自底向上地方式：先把边界设定到较小地范围，再扩大到整个系统。

    不论那种方式，边界总能够帮助我们很好地把我抽象层次，忽略掉那些边界外的杂音，专心地把当前边界内容地问题搞清楚。

** 3.5 业务实体

   业务实体 是 类（class） 的一种版型， 特别用于在业务建模阶段建立领域模型。

   如果说，参与者和用例描述了我们在这个问题领域的重要手段，那么业务实体就描述了我们使用什么来达到业务目标以及通过什么来纪录这个业务目标。

   业务实体抽象除了问题领域内核心和关键的概念，如果把问题领域比喻成一栋大楼，业务实体就是构成这栋大楼的砖瓦和石头。

   业务实体 :: 代表业务角色执行业务用例时所处理或所使用的事物。 一个业务实体经常代表某个对多个业务用例或用例实例有价值的事物。

   一个好的业务实体不包含关于其使用主体和使用方法的信息。

   业务实体时来自于现实世界的，在我们建模的问题领域里一定能够遭到与它相对应的事物，并且这个事物时参与者在完成其业务目标的过程中使用到或创建出来的。

   // 面向对象，不就是将数据模块化么？

   业务实体一定时在分析业务流程的过程中发现的，而业务流程实际上就是业务用例场景。 这意味着，业务实体必须至少被一个业务用例场景使用或创建，对业务用例没有贡献的事物，既是它是客观存在的，也不应当为它建模。

   最后，业务实体作为类的一个版型，具有对象的所有性质，包括属性和方法，同时也具有对象的独立性，即业务实体只应当包含它本身的固有的特性，而不能包含外界时如何使用它的信息。


*** 业务实体的属性

    属性时用来保存业务实体特征的一个纪录，业务实体的属性集合决定了它的唯一性。

    将面向过程的程序中，可能会一直遇到的这种数据结构和对于改种数据结构的处理方式打包到一起。然后让面向过程的程序，对这个打的包进行，共同使用，就像使用一个高级一点的函数一样，就是所谓的面向对象了把。
    当然，这个打的包一定要比较的清楚易懂，想要做到这个，也就是将这个包定义成类似于现实生活中的实体的方式，这样更加的让人理解把。

    对于函数，想要进行复用，只能进行高阶函数生成，同等类型的函数。
    对于对象的复用，这是进行 “继承”“原型” “module” 这种形式，来实现复用的吧。

*** 业务实体的方法

    方法是访问一个业务实体的句柄，它规定了外部可以怎样使用它。

    对象 和 module 的区别是不是就是 接口－interface 不同啊！！！

    方法是外部能够使用这个业务实体的全部信息。

*** 获取业务实体

** 3.6 包

   包是一种容器，如同文件夹一样，它将某些信息分类，形成逻辑单元。 使用包的目的是为了整合复杂的信息，某些语意上相关或者某方面的信息都可以分包.

   包是 UML 非常常用的一个元素，它最主要的作用就是容纳并为其他元素分类。

   包可以容纳任何 UML 元素，例如用例，业务实体，类图等，也包括子包。

   UML 认为好的包具有高内聚，低耦合的性质。

*** 包的常用版型

    * 领域包 － Domain Package
      领域包用于分类业务领域内的业务单元，每个包代表业务的一个领域，领域包视图可用于展示这些业务领域的高层次关系。

    * 子系统 － Subsystem
      用来分类系统内的逻辑对象并形成子系统

    * 组织结构 － Organization unit
      用来分类业务领域的组织结构

    * 层 － Layer
      用于分类软件中的层次，层可以用于展示软件的架构信息。

** 3.7 分析类

   分析类用于获取系统中主要的“职责簇”。他们代表系统的原型类，是系统必须处理的主要抽象概念的“第一个关口”。

   分析类是跨越需求到设计实现的桥梁。

   分析类是从业务需求向系统设计转化过程中最为主要的元素。他们在高层次抽象出系统实现业务需求的原型，业务需求通过分析类逻辑化，被计算机所了解。

   分析类总共有三个，分别是“边界类－boundary”，“控制类－control” 和 “实体类”，这些“分析类”都是类－class 的版型。

*** 边界类

    边界类是一种对系统外部环境与其内部运行之间的交互进行建模的类。这种交互包括转换事件，并纪录系统表示方式（接口）中的变更。任何有两个交互的关键对象之间都应当考虑建立边界类。

    * 参与者于用例之间应当建立边界类
    * 用例与用例之间如果有交互，应当为其建立边界类
      一个用例如果要访问另一个用例，直接访问内部对象是不好的结构，这样将导致紧耦合的发生。
    * 如果用例与系统边界之外的非人对象有交互，例如第三方系统，应当为为其建立边界类。
    * 在相关联的业务对象有明显的独立型要求，即他们可能在个字的领域内发展和变化，但有希望互不影响时，也应该为他们建立边界类。

*** 控制类

    控制类用于对一个或几个用例所特有的控制行为进行建模。 控制对象（控制类的实例）通常控制其他对象，因此他们的行为具有协调性质。控制类将用例的特有行为进行封装。

    在 UML 的定义中，认为控制类主要起到协调对象的作用，例如从边界类通过控制类访问实体类，或者实体类通过控制类防卫另一个实体类。

    在设计阶段，控制类可以被设计为 Session Bean，COM＋，Server let，java 类，cpp 类等设计类。

    从架构角度来说，控制类主要位于业务逻辑层。控制类的获取对架构设计中的业务逻辑层有着重要的指导意义。

*** 实体类

    实体类是用于对必须存储的信息和相关行为建模的类。 实体类通常是永久性的，他们所具有的属性和关系是长期需要的，又是甚至在系统的整个生存周期。

** 3.8 设计类

    将分析结构转换成实现的元素。

    设计类是系统实施中一个或多个对象的抽象；设计类所对应的对象，取决于实施语言。设计类用于设计模型中，它直接使用与编程语言相同的语言来描述。

    凡事使用过面向对象语言的朋友对类都不会陌生，到了这个阶段，设计类已经直接映射到实现代码了，因此，设计类依赖于实施语言。

    分析类为设计类中说需要的界面，逻辑和数据提供了非常好的抽象基础，设计类可以非常容易和自然地从分析类中演化出来。

    UML 为设计类地概念进行了定义： 设计类由类型，属性和方法构成。设计类的名称，属性和方法也直接映射到编码中相应的class，property，和method。

*** 类

    类对对象进行定义，而对象又实现用例

*** 小结

    设计类是分析设计工作转变为代码的最后一道工序，对大多数熟练的编程着来说并不是问题。

** 3.9 关系

*** 关联关系 － association

    对象之间知道对方的存在。

*** 依赖关系 － dependency

    一个对象的修改或导致另一个对象的修改的关系。

    和关联关系不同的是，依赖关系除了“知道”其他对象的存在，还会使用其他对象的属性或方法。

    依赖是一种特殊的关联关系。

*** 扩展关系 － extends

    与包含关系不同的是，扩展表示的是“可选”， 而不是“必须”，着意味着既是没有扩展用例，基本用例也是完整的。

    使用扩展关系的原因：
    － 表明用例的某一部分是可选的系统行为
    － 表明只在特定条件下，才执行支流

*** 包含关系 － include

    特别用于 用例 模型，说明在执行基本用例的用例使用过程中，插入的行为段。

*** 实现关系 －realize

    用例模型中，连接用例和用例实现，说明基本用例的一个实现。

*** 精化关系 － refine

    特别用于用例模型，一个基本用例可以分解出许多更小关键精化用例。精化用例展示基本用例的核心业务。

*** 泛化关系

    每个用例都应该是独一无二的，用例带有原子特性，所以不赞成使用泛化关系。使用泛化关系，很难描述用例继承了基本用例的什么。过程？还是业务实体？

*** 聚合关系

    聚合关系用于类图，特别用于表示实体对象之间的关系，表达整体由部分构成的语义。

*** 组合关系

    组合关系用于类图，表示实体对象关系，表达整体拥有部分的语义。

** 3.10 组件

   组件是系统中实际存在的可变换部分，它实现特定的功能，符合一套接口标准并实现一组接口。 组件代表系统中的一部分无力实施，包括软件代码（源代码，二进制代码或可执行代码）或等价物（如脚本或命令文件）。

   出于构建化的需要，我们把那些紧密合作的类和接口组合起来实现一组特定的功能，形成一个组件。

*** 完备性

*** 独立性

*** 逻辑性

*** 透明性

** 3.11 节点

   节点是带有至少一个处理器，内存以及可能还带有其他设备的处理元素。

   服务器，工作站，或者客户机都可以称为一个节点。

   节点是应用程序的部署单元。

   节点元素特别用于部署视图，描述应用程序在无力结构上是如何部署在应用环境中的，是一种包含软，硬件环境在内的拓扑结构描述。

*** 分布式应用环境

*** 多设备的应用环境

UML 核心元素就像是语言中的基本词汇，仅有词汇是不可能构成一篇文章的，UML 视图就像是语法，将词汇组成有意义的句子。

* 4 UML 核心视图

  如果说 UML 是一门语言，元素是 UML 的基本词汇，那么视图就是语法，UML 通过视图将基本元素组织在一起，形成有意义的句子。

  lisp 如果说，基本的 S-expression 是基础的语义，那么可视化的lisp将是真正的语法视图，语法界面。

  本章学习视图，能容包括 用例图，类图，包图 等静态视图；活动图，状态图，时序图 和 协作图 等动态视图。

  UML 可视化的特性是由各种视图来展现的，每种视图都从不同的角度对同一个软件产品的方方面面进行展示，说明将要开发的软件到底是个什么样子的。
  描述软件和描述现实世界一样，一方面我们需要描述系统的结构性特征，结构决定了这个系统能做什么；
  另一方面我们需要描述系统的运行时的行为，这些行为决定了系统怎么做。 两者结合起来，才能把系统描述清楚。

  在 UML 里， 结构性特征是用静态视图来表达的，行为性特征使用动态视图来表达的。

  // UML 是为了描述软件的，vis-racket vis-code 是用来描述代码的

** 静态视图

   静态视图就是表达静态事物的。它只描述事物的静态结构，而不描述其动态行为。 静态视图包括：用例图，类图和包图。

   用例视图采用参与者和用例作为基本基本元素，以不同的视角展现系统的功能性需求。
   用例视图是了解系统的第一个关口，人们通过用例视图得知一个系统将会做什么。
   对客户来说，用例视图是他们业务领域的逻辑化表达，对建设单位来说，用例视图是系统蓝图和开发对依赖。

*** 用例图

**** 业务用例视图

    业务用例视图需要从业务主角和业务模块两个视角进行展示。

    * 业务主角视角

      从业务主角视角来展示业务主角在业务中使用哪些业务用例来达成业务目标。

    * 业务模块视角

      从业务模块视角来展示业务领域的业务目标，将参与了达成这一业务目标的业务主角与业务用例展现在这个视图中。

      这个视角有利于从业务的完整性角度出发，检查完成某个业务的所有业务主角和业务用例是否已经齐全，以此来检查是否由一楼的业务用例没有发现。


    * 其他视角

      在建模过程中，可以根据实际需要从更多的视觉来绘制业务用例视图。

**** 业务用例实现视图

    业务用例实现视图展示业务员用例由哪些实现途径。

    如果一个业务用例由多个实现途径，则应该绘制业务用例视图俩组织实现业务的哪些业务对象和业务过程。

    无论是否有多种实现方式，绘制业务用例实现视图都是一个好习惯，是符合软件工程需求可追溯原则的好做法。

**** 概念用例视图

    概念用例视图用于展现从业务用例中经过分析分解出来的关键概念用例，并表示概念用例和业务用例之间的关系。一般来说，这些关系有扩展，包含和精化。

    概念用例不是必须的，如果业务用例是一个复杂的业务，绘制概念用例有助于喜欢和更准确地理解业务用例。

**** 系统用例视图

    系统用例

**** 系统用例实现视图
*** 类图

    类图用于展示系统中的类及其相互之间的关系。

    本质上来说，类图是现实世界问题领域的抽象对象的结构化，概念化，逻辑化描述。

    实际上，UML 解决面向对象的困难的方法源于面向对象方法中，对类理解的三个层次观点，这三个层次是：概念层，说明层 和 实现层。
    在 UML 中，从开始的需求到最终的设计类，类图也是围绕着这三个层次的观点进行建模的。类图建模是：先概念层，而后，说明层，进而 实现层；这样一个随着抽象层次逐步降低而逐步细化的过程。


**** 概念层类图

     在这个层次的类图描述的是现实世界中问题领域的概念理解，类图中表达的类与现实世界的问题领域有着明显对应关系，类之间的关系也与问题领域中实际事物的关系有着明显的对应关系。

**** 说明层类图

     在这个层次的类图考察的是类的接口而不是实现，类图中表达的类和类关系应当是对问题领域在接口层次抽象的描述。

**** 实现层类图

     类是实现代码的描述，类图中的类直接映射到可执行代码。在这个层次上，类必须明确采用那种实现语言，什么设计模式，什么通信标准，遵循什么规范等。

     实现层的类图大概是用的最普遍的，许多人在建模的时候，根本没有概念层和说明层的类图而直接跳到实现层类图。原因不是他们确认对问题领域已经足够了解，并且设计经验十分丰富，而通常是，不知道类图还有三个层次的观点。

     实现层类图位于设计阶段。 在这个阶段，类图可视为伪代码。甚至可以用工具直接将实现层类图生成可执行代码。 许多 MDA 建模工具就是通过建模来生成代码的。

     到了实现层类图，类描述 和 累关系已经到伪代码级别了。

**** sum

    类图在不同的软件声明周期也有不同的表达。

*** 包图

    建模过程中，获得的元素是非常多的，如果要将这些元素的关系都绘制出来，将如同蜘蛛网一样难以辨别。
    通过包这个容器，来从大到小，从粗到细地建立关系是一种很好的办法。

** 动态视图

   动态视图是描述事物动态行为的。需要注意的是，动态视图不能够独立存在，它必须特指一个静态视图或 UML 元素，说明在静态视图规定的事物结构下他们的动态行为。

   动态视图包括：活动图，状态图，时序图 和 协作图。

*** 活动图

    活动图描述了为了完成某一目标需要做的活动以及这些活动的执行顺序。
    UML 中有两个层面的活动图，一种用于描述用例场景，另一种用于描述对象交互。

    活动图被引入 UML 中是由争议的，因为活动图实际上描述的是 业务流程，是一种过程话的分析方法，很多人担心面向过程的活动图引入会导致面向对象的类职责的混乱，这种担心是有道理的。

    在面向对象的严重，是没有业务流程这种东西的，所谓流程只不过是在某个外部力量的推动下，对象之间交互交流的一个过程，它只是“瞬时的”。如果从互动图的观点来描述业务，实际上是不能直接看到对象是如何发挥作用的。

    这样，在观念上，很容易导致对象独立性被破坏。

---


    但是， 在 UML 中国年引入活动图可能也是无奈之举，因为从现实世界映射到对系那个世界有着诸多困难。面向对象要求对象越独立，封装度越高越好，可是面向对象越纯粹，我们越南理解这些对象将会干什么。
    正所谓，上帝什么都能做，但其实他什么都没有做： 纯粹的面向对象也许能做无数的事情，但实际上我们只需要明确其中的一件。

    我们面临这样一个矛盾，既要保持面向对象观点中的对象的独立性，又要保持现实世界中业务目标的过程化描述。 活动图的引入解决了业务目标过程化描述，但也给对象分析造成了混乱。
    虽然如此，活动图在描述用例场景时，仍然是十分有效的工具，关键还是建模者自己要避免被过程化的观点所困扰，而不必机会使用活动图。

**** 用例活动图

     活动图用来描述用例场景，也就是通常所说的业务流程。
     业务流程一般包括一个基本业务流程和一个或者多个备选业务流程，而业务流程则通过多个活动按照一定的条件和顺序执行来推进。
**** 对象活动图

     对象活动图用于展示对象的交互。

     无论是用例互动图，还是对象活动图，如果所它是一个业务流程，我们总觉得差了什么。是的，我们只知道活动的执行顺序，却不知道谁执行了这些活动。

**** 泳道

     在面向过程的分析观点里面，对象职责不重要，重要的是业务的执行过程；二面向对象的分析观点里则与之相反，业务的执行过程不是重要的，对象职责才是最重要的。

     泳道代表了一个特定的类，人，部门，层次等对象的职责区，这些对象在业务流程中，负责执行的活动构成了他们的职责。

*** 状态图

    状态图现实一个状态机。状态机用于对模型元素的动态行为进行建模，更具体的说，就是对系统行为中受事件驱动的方面进行建模。

    // 如果说，人的思维是按照，流程，或者是流程图来的，那么这些 对象之类的 abstraction 封装，都是这个思维流程周围的环境，也就是可用工具，如果需要用到的话，就进行使用。 这个 说法和以前的使用调用函数有什么区别么？
    // 这里的函数，更像是一个单独的状态系统，每次使用，都可以对这个对象，有一定的影响。这就像是对 函数的闭包 操作一样吧。

    状态机主要用于 描述对象的状态变化 以确定何种行为改变了对象状态，以及对象状态变化对系统的影响。

    // 果然，对象的状态性，让对象称为一个自己的小宇宙，这个小宇宙可能会影响很多的信息。

    我们可以使用状态机来描述业务实体对象，分析类对象和设计类对象。
    通常，状态机用于描述实体类对象的整个声明周期内的状态变迁以及获得对这个实体对象的理解。

*** 时序图

    时序图用于描述按照事件顺序排列的对象之间的交互模式。

    时序图描述了参与交互的对象中说发生的事件，以及这些对象之间如何相互发送消息进行通信。

    对象的核心就是职责和接口。

    时序图与协作图可以相互转换，与协作图不同的是，时序图强调消息事件的发生顺序，更方便与阐述事件流的过程：但是时序图却难以表达对象之间关系。

    三个层次的时序图是： 业务模型时序图，概念模型时序图，设计模型时序图。

**** 业务模型时序图

     业务模型时序图用于为领域模型中的业务实体交互建模，其目标是实现业务用例。

     非常清晰的分辨出对象的职责，生命周期，和会话过程。

     - 对象
       表示参与交互的对象。每个对象都带有一条生命周期线，对象被激活（创建或者被引用）时，生命周期线上会出现一个长条（会话），表示对象的存在。

     - 生命周期线
       生命周期线表示对象的存在，当对象被激活时（创建或者被引用）时，生命周期线上出现会话会，表示对象参与了这个会话。

     - 消息
       消息由一个对象的生命周期线指向另一个对象的生命周期线。如果消息知道空白的生命周期线，将创建一个新的会话；如果详细知道已有的会话，表示该对象延续已有会话。

     - 会话
       会话表示一次交互，在会话过程中所有对象共享一个上下文环境。例如事物上下文，安全上下文等。
     - 销毁
       销毁绘制在生命周期线上，表示对象生命周期的终止。

     时序图表达的内容会对将来的分析带来帮助，但是相对于编码实现来讲由于太粗略而不能够作为依据。

      // 对象 和 函数 的另一的区别：好像是，DNS 查询一样， 递归式的查询，迭代式查询方式。 对象就像是 递归式的，对象需要掌握它可以联系的下一个操作的对象。函数，只是处理自己的事情，然后返回，你继续进行自己的处理。

      时序图有些像是，对象直接的使用，但是他将这种，时许上的过程流，竟然也用对象交互表示，有些不太对劲。

**** 概念模型时序图

**** 设计模型的时序图

     设计模型时序图使用设计类作为对象绘制。目标是实现概念模型中的某个事件流，一般以一个完整交互为单位，消息系知道方法级别。

     消息细致到方法级别。。。

     显然，在实际工作中我们很难为所有的交互都绘制时序图，那将是一个巨大的工作量。统一方法讲究架构驱动，并且近几年来不使用软件框架的软件项目已经很少了。

     在设计模型阶段，只需要用框架中的关键累描述典型的交互场景即可，不需要为每个交互都绘制时序图。

     参考框架事件流即可，不需要一一绘制。

*** 协作图

    协作图描述了对象件交互的一种模式：它通过对象之间的链接和他们相互发送的消息来现实参与交互的对象。

    协作图用来显示对象之间如何进行交互以执行特定用例或用例中特定部分的行为。协作图的建模结果用于获取对象的职责和结果。与时序图不同的是，协作图因为展示了对象间的关系，使得它更加适用于获得对对象结构的理解，而时序图则更适用于调用过程的理解。

    由于面向对象的缘故，时序图 和 协作图不能同时展示出来。 这种图形，一个固定的目标的各个对象直接的互相依赖使用关系。


** Sum

    面向对象的系统，将所有的元素都看作是静态的，等待交流的。
    然后，不知道为什么就出现了这种，互相之间的可能会用到的互相调用。
    然后，就形成了不同的各种功能。
