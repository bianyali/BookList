#+TITLE:       Documents on IBM developerworks
#+AUTHOR:      Yali Bian
#+EMAIL:       bianyali@hotmail.com
#+DATE:        2015-08-06 Thu


* Scheme 程序语言介绍之一

** Scheme 的历史和沿革

   据说一开始 McCarthy 只想把这门他正在设计 的语言的语法的设计，往后拖一拖，等到后面有趣的工作做完了，再回头来给这门基于 Lambda 演算的程序语言加上为数学家们所熟悉的语法。可是 McCarthy 的一个学生很快发 现，直接在还没有正式语法的抽象语法里面写程序，感觉非常好。就用不着一个正式的语法了。于是 Lisp 诞生了。

   Lisp 重要的特征就是：
     - 第一，基于 Lambda 演算的计算模型；
     - 第二，加上 List processing，这也是 Lisp 名称的由来；
     - 第三，直接在抽象语法里面工作， 这是非常特别的。
   前两个重要特征，是 McCarthy 天才的设计，第三个特征则是有趣的巧合。

   传统的 Macro，在 R5RS 的作者眼中，有严重的缺陷，则促使他们在 R5RS 中发明了 “卫生”的 Macro。 可是后来这种卫生的 Macro，反过来又遭到了传统 Lisp 支持者的严厉批评。

   对于*程序语言理论*不太熟悉的读者，Lexical scope 和 Dynamic scope，还有基于 Lambda 演算的 List processing，以及 Continuation 和卫生的 Macro，这些概念可能让人摸不着头脑.

** Lambda

** 高阶函数
    高阶函数是 Lambda 演算理论的精髓，是有Lisp首先介绍到程序语言这个世界的。高阶函数有两点内容：第一，让函数成为程序语言中的所谓的“第一等公民”，就像轮子既是一种工具，我们可以使用它，也是一种对象，我们可以对他进行操作，是一样的。 把这些“第一等公民”放到我们的变换函数里面，对他们进行任意的，我们所需要的各种各样的操作。

** 匿名函数

    把数据对象和变量名称剥离开来的原则，对于程序员来说，是非常打的解脱。

    除了高阶函数这个本质的东西以外，Lambda 在 Scheme 里面还代表了一种原则。 这个原则就是把程序语言中的对象和对象名字分离开来，并且允许使用匿名对象。

** 直接在抽象语法上工作

   s-expr 对于匿名函数的定义和调用，看起来要比js中的匿名函数的实现和调用，要简明和美观很多。

   Lisp 程序可以看成是完全由“函数调用”这个单一的语法结构构成的。 Lisp 里面没有为了算术表达式，或者逻辑表达式，或者语言关键字，比如 IF 和 THEN，来准备特别的语法结构。所有的语言元素都是按照这个简单一致的语法结构来安排的。Lisp 按照 Lambda 演化发展的计算模型有对高阶函数的支持。 而高阶函数在一般的程序里面是不存在的。 S－expr 就是一般的程序语言在经过语法分析后，编译器得到的抽象语法树的表示形式。

   Lisp 语言语法上面这样安排，有一个明显的好处，还有一个明显的坏处：

     － 明显的好处，就是陈许愿不用像在其他程序语言里面那样，去特别记忆各种不同的语法结构，以及这些结构之间进行组合所需要考虑的优先级的安排，结合律的安排，以及语法变形的安排。 这些问题统统一去不复返。 S-exp 的第一个单词决定了 S-exp 的意义，剩下的单词都是参数。记住这一条规则就足够了。

     - 明显的坏处就是，大量的使用括号，以及括号的深层嵌套，使得括号匹配成了件让人畏惧的事。这是为什么 Lisp 程序员无一例外的喜欢 Emacs 编辑器的原因。

** List Processing

   List 是 Lisp 中最重要的数据结构。 car, cdr 和 cons 就是 Lisp Processing 游戏里面的最基础的三条规则。这三条规则不会引起任何有关规则的争吵，但这样玩比较浪费时间，通常大家都会用这三条规则定义一些更高级，也更复杂的规则，加快游戏进度。而 Macro 规则恰恰相反。就像扑克牌里数不清的各种个样的奇怪的规则一样。虽然这些不同风格的 Macro 规则本质上是一样的。 但是大量微妙的细节，也会让新加入的人感到困惑和不适应。

** 简单的二叉树

   许多程序语言的设计者都看不到这一点对于程序语言的重要影响。一个简单，一致，而且足够强大的数据类型，对于程序员来说，是非常重要的事情。

** Macro

   R5RS 中的 Macro 采用模式匹配的方式来定义和使用。首先，用 Macro 编写者提供的模式，去匹配程序中响应的 s-exp 表达式。 如果发生匹配，按照匹配的效果，给模式中的变量赋值。 模式中的这些变量得到相应的赋值。模式中的变量得到相应的赋值后，就可以用这些变量，再按照由 Macro 编写者所提供的，和匹配的模式对应的模版，来生成另一个 s-exp 表达式。 Macro 的效果就是由一个 s-exp，翻译成两一个 s-exp。 用到一个模式匹配，再用到一个相应的模版改写。这就是 Macro 简单明了的语意。

   匹配 ＋ 改写规则 :: 匹配用的模式以及改写用的模版。
   每个模式都对应一个模版。一个模式就是一个 s-exp。第一个单词为“macro-name” 或者简单的写成“_”。 表达式中出现的其他单词，不管位于层次多深的嵌套括号之中，只要不是在前面定义中出现的literal中的一员，就被当作当前模式的一个变量。如果这个模式确实放生了匹配，这些变量就被赋予相应的匹配所捕获的单词。

** 级联的 Macro

* Scheme 语言概要

** 基本概念

*** 块(form)

    块(form)是Scheme语言中的最小程序单元，一个Scheme语言程序是由一个或多个form构成。 没有特殊说明的情况下 form 都由小括号括起来，形如：

#+BEGIN_SRC Racket
(define x 123)
(+ 1 2)
(* 4 5 6)
(display "hello world")
#+END_SRC

    一个 form 也可以是一个表达式，一个变量定义，也可以是一个过程。

*** 变量定义

    可以用define来定义一个变量，形式如下：
    (define 变量名 值)
    如：
    (define x 123) ，定义一个变量x，其值为123。

*** 符号型(symbol)
    符号类型是 Scheme 语言中有多种用途的符号名称，它可以是单词，用括号括起来的多个单词，也可以是无意义的字母组合或符号组合，它在某种意义上可以理解为C中的*枚举类型*。

*** 列表与pair的关系

    列表是在点对的基础上形成的一种特殊格式。
    list是pair的子类型，list一定是一个pair，而pair不是list。

    在Scheme语言中，每种数据类型都有一些基本的和它相关的操作过程，如字符串，列表等相关的操作，这些操作过程都很有规律，过程名的单词之间都用-号隔开，很容易理解。
    对于学过C++的朋友来说，更类似于某个对象的方法，只不过表现的形式不同了。

*** eq?，eqv?，equal?

    eq?，eqv?和equal?是三个判断两个参数是否相等的过程，其中eq?和eqv?的功能基本是相同的，只在不同的Scheme语言中表现不一样。

    eq?是判断两个参数是否指向同一个对象，如果是才返回#t；
    equal?则是判断两个对象是否具有相同的结构并且结构中的内容是否相同，它用eq?来比较结构中成员的数量；
    equal?多用来判断点对，列表，向量表，字符串等复合结构数据类型。

** 过程定义

*** 过程（Procedure）

    在Scheme语言中，过程相当于C语言中的函数，不同的是Scheme语言过程是一种数据类型，这也是为什么Scheme语言将程序和数据作为同一对象处理的原因。

** 常用结构

*** 顺序结构

*** if结构

*** case/cond/and/or

** 递归调用

*** 循环的实现

    在Scheme语言中没有循环结构，不过循环结构可以用递归来很轻松的实现（在Scheme语言中只有通过递归才能实现循环）。

** 变量和过程的绑定

   在多数编程语言中都有关于变量的存在的时限问题.
   Scheme语言中用let，let*和letrec来确定变量的存在的时限问题，即局部变量和全局变量.
   一般情况下，全局变量都用define来定义，并放在过程代码的外部；而局部变量则用let等绑定到过程内部使用。

*** 过程绑定

    除了apply，map以外，Scheme语言中还有很多，诸如：
      eval，delay，for-each，force，call-with-current-continuation等过程绑定的操作定义，
    它们都无一例外的提供了相当灵活的数据处理能力，也就是另初学者望而生畏的算法，当你仔细的体会了运算过程中用到的简直妙不可言的算法后，你就会发现Scheme语言设计者的思想是多么伟大。

*** apply

    apply的功能是为数据赋予某一操作过程，它的第一个参数必需是一个过程，随后的其它参数必需是列表.

** 输入输出

   Scheme语言中也提供了相应的输入输出功能，是在C基础上的一种封装。

** 其它功能

*** 模块扩展

    在R5RS中并未对如何编写模块进行说明，在诸多的Scheme语言的实现当中，几乎无一例外的实现了模块的加载功能。
    所谓模块，实际就是一些变量、宏定义和已命名的过程的集合，多数情况下它都绑定在一个Scheme语言的符号下（也就是名称）。

* Scheme 语言深入

  在Scheme语言中，符号类型的用法、过程的多参数情况、Continuation、记录类型、宏定义与模块等等一些问题成为阻挡初学者的门槛，也是深入理解和使用Scheme语言编程的关键。

** 关于符号类型

   符号类型又称引用类型，在概要一文中本人介绍得非常的模糊，使很多初学者不理解。
   符号类型在 Scheme 语言中是最基础也是最重要的一种类型，这是因为 Scheme 语言的祖先 Lisp 语言的最初目的就是符号处理。
   在 Scheme 语言中几乎所有的东西都可以看做是符号或做为符号列表来处理，这也是我们把符号类型做为第一个问题研究的原因。

   用quote定义的列表的类型仍是列表，而列表中的某一值的类型则是符号类型。

   #+BEGIN_SRC Racket

   (list 'a 'b 'c 'd 'e)      ==>  '(a b c d e)

   '(a b c d e)               ==>  ;wrong :: (quote (list a b c d e))
   (+ 1 (+ 2 (+ 3 (+ 4 5))))  ==>  (+ 1 2 3 4 5)

   #+END_SRC

   两者有异曲同工之妙，减少了多余的操作符，使表达式更直观，更容易理解。

   从 '(1 2 3 4 5) ==> (1 2 3 4 5) 可以看出，由符号类型的定义来形成列表，这是Scheme语言继承自LISP语言的传统。list 是非常重要的类型。

   从示例中我们可以看出，这些应用多数与列表有关，而处理列表是Scheme语言的关键所在。
   符号类型的用法对深入理解Scheme语言也非常关键，因为Scheme语言本身就可以理解为是这种符号类型的列表，处理符号类型就是处理Scheme语言本身。

** 关于过程参数的问题

   过程的多参数问题对初学者不太好理解，一般情况下我们处理过程时，过程参数的数量是固定的，当过程的参数数量不固定时怎么办呢？对了，时刻记住列表，把过程的参数做为一个列表来处理。

** 关于continuation

   Scheme语言相对Lisp语言的重要特征是提出并实现了continuation，这是让初学者最难理解，也是最让程序员心动的特征。

*** 解决 yin-yang 问题

    要执行continuation 也是需要小括号的“()”!!!

** 关于宏定义

   Scheme语言中的宏定义类似于自己定义一个Scheme语言关键字，可以实现不同的功能。
   很多关键字都可以通过宏定义来实现，我们在多数参考资料中都可以看到这样的例子。
