#+TITLE:       The Scheme Programming Language
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-07-11 Sat



* Preface

* Ch1. Introduction

** General-purpose Language

   Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters.

** The core of Scheme

   At the heart of the Scheme language is a small core of syntatic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language. An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. The extended syntatic forms and primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.

** Representation of Scheme programs

   Scheme programs share a common printed representation with Scheme data structures. As a result, any Scheme program has a nature and obvious internal representaion as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for syntactic extension facilities provided by Scheme for the definition of new syntactic in terms of existing syntactic forms and procedures. It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, as well as program transformation tools for other languages in Scheme.

** Procedure definition

   In most languages, a procedure definition is simply the association of a name with a block of code. Certain variables local to the block are the parameters of the procedure. In some languages, a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block. In others, procedures can be defined only at top level. In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.
** Tail recursion

   Scheme implementation are required to implement tail calls as jumps (gotos), so the storage overhead normally associated with recursion is avoided. As a result, Scheme programmers need master only  simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.

** Continuations

   Scheme supports the definition of arbitrary control structures with continuations. A continuation is a procedure that embodies the remainder of a program at a given point in the program. A continuation may be obtained at any time during the execution of a program. As with other procedures, a continuation is a first-class object and many be invoked at any time after its creation. Whenever it is invoked, the program immediately continues from the point where the continuation was obtained. Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.

** Syntactic extension

   These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer. Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme. Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.
** Scheme Syntax

   Scheme Programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.

   Identifies are delimited by whitespace, comments, brackets, string (double) quote ("), and hash marks(#).

** Standard printed representation

   Some Scheme values, such as procedures and ports, do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. #<description> would be used as a notation when showing the output of an operation that returns such a value, e.g., #<procedure> or #<port>
* CH2. Getting Started

** data structures and control mechanisms

   其实程序里面除了要考虑 data structure，还要考虑 control mechanisms. However 由于将 control mechanisms 硬性的规定成了 顺序流动，for循环，while 循环，if 语句分支选择，差不多没有别的了。 不可否认，这样确实很好的让 programmer 和 code reader 理解程序，但却将 programs 的种类也硬性死板了。缺少了 goto 的这种胆大妄为。
** Aggregate data structure - List

   You might notice that lists look just like procedure applications and wonder how Scheme tells them apart. That is, how does Scheme distinguish between a list of objects, (obj1 obj2), and a procedure application, (procedure arg ...)?

   In some cases, the distinction might seem obvious. The list of numbers (1 2 3 4 5) could hardly be confused with a procedure application, since 1 is a number. So, the answer might be that Scheme looks at the fist element of the list or procedure application and makes its decision based on whether that first element is a procedure or not. This answer is not good enough, since we might even want to treat a valid procedure application such as (+ 3 4) as a list. The answer is that we must tell Scheme explicitly to treat a list as a data rather than as a procedure application. We do this with quote.

   #+begin_src racket
(quote (1 2 3 4 5))
(quote ("this" "is" "a" "list"))
(quote (+ 3 4))
   #+end_src

   The quote forces the list to be treated as data. Try entering the above expressions without the quote; you will likely receive a message indicating that an exception has occurred for the first two an an incorrect answer (7) for the third.

   Because quote is required fairly frequently in Scheme code, Scheme recognizes a single quotation make (') preceding an expression an a abbreviation for quote.

   #+begin_src racket
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
   #+end_src

   Both forms are referred to as quote expressions. We often say an object is quoted when it is enclosed in a quote expression.

   A quote expression is not a procedure application, since it inhibits that evaluation of its expression. It is an entirely different syntactic form. Scheme supports several other syntactic forms in addition to procedure applications and quote expressions. Each syntactic form is evaluated differently. Fortunately, the number of different syntactic form is small.

   You might wonder why applications and variables share notations with lists and symbols. The shared notation allows Scheme programs to be represented as Scheme data, simplifying the writing of interpreters, compilers, editors, and other tools in Scheme.

   Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb. Creating a new list by adding an element to the beginning of a list is referred to as consing the element onto the list.
** Evaluating scheme expression

   Let's turn to a discussion of how Scheme evaluates the expression you type. We have already established the rules for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out in your mind a rule for evaluating procedure applications of the form

#+begin_src racket
(procedure arg1 ... argn)
#+end_src


   Here, procedure is an expression representing a Scheme procedure, amd arg1 ... argn are expressions representing its arguemts. One possibility is the following:

#+begin_src racket
; Find the value of procedure.
; Find the value of arg1
; ...
; Find the value of argn
; Apply the value of procedure to the values of arg1 ... argn.
#+end_src

   For example, consider the simple procedure application (+ 3 4). The value of + is the addition procedure, the value of 3 is the number 3, and the value of 4 is the number 4. Apply the addition procedure to 3 and 4 yields 7, so our value is the object 7.

** Procedure and other syntactic forms

   The procedure evaluation rule works for procedure applications but not for quote expression because the subexpressions of a procedure application are evaluated, whereas the subexpression of a quote expression is not. The evaluation of a quote expression is more similar to the evaluation of constant objects. The value of a quote expression of the form (quote object) is simply object.

   Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Schemer programmer; there are referred as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining sections of this chapter. Section 3.1 summarizes the core syntactic forms and introduces the syntactic extension mechanism.

** Let syntactic form

   We say the variable are bound to the values by the let. We refer to variables bound by let as let-bound variables.

   A let expression is often used to simplify an expression that would contain two identical subexpressions. Doing so also ensures that the value of the common subexpression is computed only once.

#+begin_src racket

(+ (* 4 4) (* 4 4))
(let ((a (* 4 4)))
     (+ a a))

#+end_src

   The variable bound by let are visible only within the body of the let.

   Although choosing different names can sometimes prevent confusion, showing can help prevent the accidental use of an "old" value. For example, with the original version of the preceding example, it would be impossible for us to mistakenly refer to the outer x within the body of the inner let.
** Procedure

   A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed representation as far as Scheme is concerned.

   #<procedure> to show that the value of an expression is a procedure.

   Because procedure are objects, we can establish a procedure as the value of the variable and use the procedure more than once.

   What happends when the procedure is applied somewhere outside the scope of the bindings for variables that occur free within the procedure, as in the following expressions?

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (f 'i 'am))

#+end_src

   The answer is that the same bindings taht were in effect when  the procedure was created are in effect again when the procedure is applied. This is true even if another binding for x is visible where the procedure is applied.

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (let ([x 'not-sam])
      (f 'i 'am)))

#+end_src

   Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of argument expression. For example, the two expressions below are equivalent.

#+begin_src racket

(let ([x 'a])
   (cons x x))

((lambda (x)
    (cons x x))

 'a)

#+end_src

   In fact, a let expression is a syntactic extension defined in terms of lambda and procedure application, which are both core syntactic forms.

** Top-level definitions

   A top-level definition many be established for any object, not just for procedures.

   As suggested above, top-level definitions may be shadowed by let or lambda bindings.

   Variables with top-level definitions act almost as if they were bound by a let expression enclosing all of the expression you type.
** Simple Recursion

   Readers who are familiar with other languages that provide special iteration constructs, e.g., while or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary; iteration in Scheme is expressed more clearly and succinctly via recursion.

   Recursion is more general and eliminates the need for the variable assignments required by many other languages' iteration constructs, resulting in code that is more reliable and easier to follow.
** Assignment

   Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings.

   Many languages require the use of assignments to initialize variables, separate from the declaration or binding of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to initialize them, a common source of errors in most languages.

   In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One common practice in some languages is to sequence expression evaluation with a series of assignments, as in the following procedure that finds the roots of a quadratic equation.

#+begin_src racket
(define quadratic-formula
   (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
)))
#+end_src

   Assignments are commonly used to implement procedures that must maintain some internal state.
** Lazy evaluation

   Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than once.

* Ch3. Going Further

** Syntactic extension
** More recursion

   Recursion in general  and named let in particular provide a natural way to implement many algorithms, whether iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct mechanisms.

   It often happens that one recursive call within the same expression is tail-recursive while another is not.

** Tail position

   A call is in tail position with respect to a lambda expression if its value is returned directly from the lambda expression, i.e., if nothing is left to do after the call but to return from the lambda expression. For example, a call in tail position if it is the last expression in the body in the body of a lambda expression, the consequent or alternative part of an if expression in tail position, the last subexpression of an and or or expression in tail position, the last expression in the body of a let or let rec in tail position, etc. Each of the calls to f in the expressions below are tail calls, but the calls to g are not.

** Continuations

   During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. Consider the evaluation of (null? x) within the expression below.

#+begin_src racket

(if (null? x)
  (quote ())
  (cdr x))

#+end_src

   The implementation must first evaluate (null? x) and, based on its value, evaluate either (quote ()) or (cdr x). "What to evaluate" is (null? x), and "what to do with the value" is to make the decision which of (quote ()) and (cdr x) to evaluate and to do so. We call "what to do with the value" the continuation of a computation.

   Thus, at any point during the evaluation of any expression, there is a continuation ready to complete, or at least continue, the computation from that point. Let's assume that x has the value (a b c). We can isolate six continuations of (if (null? x) (quote ()) (cdr x)), the continuations waiting for:

   + 1. the value of (if (null? x) (quote ()) (cdr x)),
   + 2. the value of (null? x),
   + 3. the value of null?
   + 4. the value of x,
   + 5. the value of cdr, and
   + 6. the value of x (again).

   The continuation of (cdr x) is not listed because it is the same as the one waiting for (if (null? x) (quote ()) (cdr x)).

   Scheme allows the continuation of any expression to be captured with the procedure call/cc. call/cc must be passed a procedure p of one argument. call/cc constructs a concrete representation of the current continuation and passes it to p. The continuation itself is represented by a procedure k. Each time k is applied to a value, it returns the value to the continuation of the call/cc application. This value becomes, in essence, the value of the application of call/cc.

   If p returns without invoking k, the value returned by the procedure becomes the value of the application of call/cc.

*** Demos of continuation

   The following variation of the example above is probably the most confusing Scheme program of its size; it might be easy to guess what it returns, but it takes some thought to figure out why.

#+BEGIN_SRC racket

; most confusing Scheme program of its size;
(((call/cc (lambda (k) k))
  (lambda (x) x))
 "HEY!")

#+END_SRC

   The value of the call/cc is its own continuation, as in the preceding example. This is applied to the identity procedure (lambda (x) x), so the call/cc returns a second time with this value. Then, the identity procedure is applied to itself, yielding the identity procedure. This finally applied to "HEY!", yielding "HEY!".

-----

   Continuations used in this manner are not always so puzzling. Consider the following definition of factorial that saves the continuation at the base of the recursion before returning 1, by assigning the top-level variable retry.

#+BEGIN_SRC racket

; most confusing Scheme program of its size;
(((call/cc (lambda (k) k))
  (lambda (x) x))
 "HEY!")


; factorial
(define retry #f)

(define factorial (lambda (x)
                    (if (= x 0) (call/cc (lambda (k) (set! retry k) 1))
                        (* x (factorial (- x 1))))))


#+END_SRC

   With this definition, factorial works as we expect factorial to work, except it has the side effect of assigning retry.

#+BEGIN_SRC racket

(factorial 4) ; -> 24
(retry 1)     ; -> 24
(retry 2)     ; -> 48

#+END_SRC

   The continuation bound to retry might be described as "Multiply the value by 1, then multiply this result by 2, then multiply this result by 3, then multiply this result by 4." If we pass the continuation a different value, i.e., not 1, we will cause the base value to be something other than 1 and hence change the end result.

#+BEGIN_SRC racket

(retry 2)     ; -> 48
(retry 4)     ; -> 120

#+END_SRC

   This mechanism could be the basis for a breakpoint package implemented with call/cc; each time a breakpoint is encountered, the continuation of the breakpoint is saved so that the computation may be restarted from the breakpoint (more than once, if desired).

** Continuation Passing Style

   As we discussed in the preceding section, a continuation waits for the value of each expression. In particular, a continuation is associated with *each procedure call*. When one procedure invokes another via *nontail call*, the *called procedure* receives an implicit continuation that is responsible for completing what is left of the *calling procedure's body* plus returning to the *calling procedure's continuation*. If the call is a tail call, the called procedure simply receives the *continuation of the calling procedure*.

   We can make the continuation explicit by encapsulating "What to do" in an exaplicit procedural argument passed along on each call. For example, the continuation of the call to f in

   #+BEGIN_SRC Scheme

; explicit continuation
; -> (d b a c)
(letrec ([f (lambda (x)
              (cons 'a x))]
         [g (lambda (x)
              (cons 'b (f x)))]
         [h (lambda (x)
              (g (cons 'c x)))])
  (cons 'd (h '())))

   #+END_SRC

   conses the symbol /b/ onto the value returned to it, then returns the result of this cons to the continuation of the call to g.


   Expression written in CPS are more complicated, of course, but this style of programming has some useful applications. CPS allows a procedure to pass more than one result to its continuation, because the procedure that implements the continuation can take any number of arguments.

    At this point you might be wondering about the  relationship between CPS and the continuations captured via call/cc. It turns out that any program that uses call/cc can be rewritten in CPS without call/cc, but a total rewrite of the program (sometimes including even system-defined primitives) might be necessary.
** Internal Definitions

   In fact, internal variable definitions and letrec are practically interchangeable. The only difference, other than the obvious difference insyntax, is that variable definitions are guaranteed to be evaluated from left to right, while the bindings of a letrec may be evaluated in any order. So we cannot replace a lambda, let, or letrec body containing internal definitions with a letrec expression. We can, however, use letrec*, which, like let*, guarantees left-to-right evaluation order.

   Another different between internal definitions and letrec or letrec* is that syntax definitions may appear among the internal definitions, while letrec and letrec* bind only variables.

   The scope of a syntactic extension established by an internal syntax definition, as with an internal variable definition, is limited to the body in which the syntax definition appears.

** Modularize programs

   Internal definitions may be used in conjunction with top-level definitions and assignments to help modularize programs. Each module of a program should make visible only those bindings that are needed by other modules, while hiding other bindings that would otherwise clutter the top-level namespace and possibly result in unintended use or redefinition of those bindings. A common way of structuring a module is shown below.

** Libraries
* CH4. Procedures and Variable Bindings

** Variable References

   Syntax :: variable
   returns :: the value of /variable/

   Any identifier appearing as an expression is a variable, if a visible binding for the identifier exists, e.g., the identifier appears within the scope of a binding created by define, lambda, let, or some other variable-biding construct.

** Lambda

   Syntax :: (lambda formals body1 body2 ...)
   returns :: a procedure
   libraries :: (rnrs base), (rnrs)

   The lambda syntactic form is used to create procedures. Any _operation_ that _creates a procedure_ or _establishes local variable bindings_ is ultimately defined in terms of lambda or case-lambda.

   Procedures do not have a printed representation in the usual sense. Scheme systems print procedures in different ways; this book uses the notation #<procedure>.

** Case-Lambda

   The case-lambda syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments. case-lambda is based on the lambda* syntax form introduced in the article "A New Approach to Procedures with Variable Arity".

   Syntax :: (case-lambda clause ...)
   returns :: a procedure
   libraries :: (rnrs control), (rnrs)

   A case-lambda expression consists of a set of clauses, each resembling a lambda expression. Each clause has the form below.

   [formals body1 body2 ...]

** Local Binding

   Syntax :: (let ((var expr) ...) body1 body2 ...)
   returns :: the values of the final body expression
   libraries: (rnrs base), (rnrs)

   /let/ establishes local variable bindings. Each variable var is bound to the value of the corresponding expression expr. The body of the let, in which the variable are bound, is the sequence of subforms body1, body2 ... and is processed and evaluated like a lambda body.

   Use /let/ whenever the values in expr the values are independent of the variables and the order of evaluation is unimportant.

   Syntax :: (let* ((var expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

   /let*/ is similar to /let/ except that the expression expr ... are evaluated in sequence from left to right, and each of these expressions is within the scope of the variables to the left. Use /let*/ when there is a linear dependency among the values or when the order of evaluation is important.

   Syntax :: (letrec ((var expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

   /letrec/ is similar to /let/ and /let*/, except that all of the expression expr ... are within the scope of the variables var .... /letrec/ allows the definition of mutually recursive procedures.

** Multiple Values

   Syntax :: (let-values ((formal expr) ...) body1 body2)
   Syntax :: (let*-values ((formal expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

** Variable Definitions

   Syntax :: (define var expr)
   Syntax :: (define var)
   Syntax :: (define (var0 var2 ...) body1 body2 ...)


** Assignment

   syntax :: (set! var expr)
   returns :: unspecified
   libraries :: (rnrs base), (rnrs)

* CH5. Control Operations

  This chapter introduces the syntactic forms and procedures that serve as control structures for Scheme programs. The first section covers the most basic control structure, procedure application, and the remaining sections cover sequencing, conditional evaluation, recursion, mapping, continuation, delayed evaluation, multiple values, and evaluation of programs constructed at run time.

** Procedure Application

   syntax :: (expr0 expr1)
   return :: values of applying the value of expr0 to the values of expr1 ...

   Procedure applications is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application.

   The expression expr0 and expr1 ... are evaluated: each should evaluate to a single value. After each of these expression has been evaluated, the value of expr0 is applied to the values of expr1 ... . if expr0 does not evaluated to a procedure, or if the procedure does not accept the number of arguments provided, an exception with condition type &assertion is raised.

   The order in which the procedure and argument expressions are evaluated is unspecified. It may be left to right, right to left, or any other order. The evaluation is guaranteed to be sequential, however: whatever order is chosen, each expression is fully evaluated before evaluation of the next is started.

*** apply

    /apply/ are useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.

** Sequencing

   syntax :: (begin expr1 expr2 ...)
   returns :: the values of the last subexpression
   libraries :: (rnrs base), (rnrs)

   The expressions expr1 expr2 ... are evaluated in sequence from left to right. /begin/ is used to sequence assignments, input/output, or other operations that cause effects.

** Conditionals

   procedure :: (not obj)
   returns :: #t if obj is false, #f otherwise

   /not/ is not equivalent to (lambda (x) (if x #f #t))


   Syntax :: (and expr ...)
   returns :: see below
   libraries :: (rnrs base), (rnrs)

   If no subexpression are present, the and form evaluates to #t. Otherwise, and evaluates each subexpression *in sequence* from left to right until only one subexpression remains or a subexpression returns #f.

   Syntax :: (cond clause1 clause2 ...)
   returns :: see blow

   Each /test/ is evaluated in order until one evaluates to a true value or until all of the tests have been evaluated.


   A /when/ or /unless/ expression is usually clearer than that corresponding "one-armed" /if/ expression.

   Syntax :: (case expr0 clause1 clause2)
   returns :: see below

** Recursion and Iteration

   This form of let, called named-let, is a general-purpose iteration and recursion construct.

** Mapping and Folding

   exists :: (exits procedure list1 list2)

   (exits symbol? '(1.0 #\a "hi" '()))

** Continuations

   Continuations in Scheme are *procedures* that represent the remainder of a computation from a given point in the computation. They may be obtained with call-with-current-continuation, which can be abbreviated to call/cc.

   procedure :: (call/cc procedure)
   procedure :: (call-with-current-continuation procedure)

   call/cc obtains its continuation and passes it to procedure, which should accept one argument. The continuation itself is *represented by a procedure*. Each time this procedure is applied to zero or more values, it returns the values to the continuation of *the call/cc application*. That is, when the continuation procedure is called, it returns its arguments as the values of the application of call/cc.

   If /procedure/ returns normally when passed the continuation procedure, the values returned by call/cc are the values returned by procedure.

   Continuation allow the implementation of nonlocal exits, backtracking, coroutines, and multitasking.

   The current continuation is typically represented internally as *a stack of procedure activation records*, and obtaining the *continuation* involves *encapsulating the stack* within a procedural object. Since an encapsulated stack has indefinite extent, some mechanism must be used to preserve the stack contents indefinitely. This can be done with surprising ease and efficiency and with no impact on programs that do not use continuations.

** Delayed Evaluation

   The syntactic form delay and the procedure force may be used in combination to implement lazy evaluation. An expression subject to lazy evaluation is not evaluated until its value is required and, once evaluated, is never reevaluated.

   syntax :: (delay expr)
   returns :: a promise
   procedure :: (force promise)
   libraries :: (rnrs r5rs)

   delay and force are typically used only in the absence of side effecs, e.g., assignments, so that the order of evaluation is unimportant.

   The benefit of using delay and force is that some amount of computation might be avoid altogether if it is delayed until abosolutely required. Delayed evaluation may be used to construcut conceptually infinite lists, or stream.

** Multiple Values

   While all Scheme Primitives and most user-defined procedures return exactly one value, some programming problems are best solved by returning zero values, more than one value, or even a variable number of values. For exmaple, a procedure that partitions a list of values into two sublists needs to return two values.
   The former procedure produces multiple values and the latter links procedures that produce multiple-value values with procedures that comsume them.

** Eval

* CH6. Operations on Objects

  There is no section treating operations on procedures, since the only operations defined specifically for procedures is application, and this is described in Chapter 5.


** Constants and Quotation

   syntax :: constant
   returns :: constant

   constant is any self-evaluating constant, i.e., a number, boolean, character, string, or bytevector. Constants are immutable.

   quote inhibits the normal evaluation rule for obj, allowing obj to be employed as data. Although any Scheme object may be quoted, quotation is not necessary for self-evaluating constants, i.e., numbers, booleans, characters, strings, and bytevectors.

*** quasiquote

    quasiquote is similar to quote, but it allows parts of the quoted text to be "unquoted." Within a quasiquote expression, unquote and unquote-splicing subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each unquote subform is inserted into the output in place of the unquote form, while the value of each unquote-splicing subform is spliced into the surrounding list or vector structure. unquote and unquote-splicing are valid only within quasiquote expression.

    /unquote/ and /unquote-splicing/ are auxiliary keywords for quasiquote. It is syntax violation to reference these identifiers except in context where they are recognized as auxiliary keywords.

** Generic Equivalence and Type Predicates

   In most Scheme systems, two objects are considered identical if they are represented internally by the same pointer value and distinct (not identical) if they are represented internally by different pointer values, although other criteria, such as time-stamping, are possible.

   Although the particular rules for object identity vary somewhat from system to system, the following rules always hold.


*** eq?

    #t if obj1 and obj2 are *identical*, #f otherwise.

    eq? is most often used to compare symbols or to check for pointer equivalence of allocated objects, e.g., pairs, vectors, or record instances.

*** eqv?

    #t if obj1 and obj2 are *equivalent*, #f otherwise.

*** equal?

    #t if obj1 and obj2 have the same *structure and contents*, #f otherwise.

*** boolean?

*** integer-valued?, rational-valued?, integer-valued?

    These predicates are similar to real?, rational?, and integer?, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts.

** Lists and Pair

   The pair, or cons cell, is the most fundamental of Scheme's structured object types. The most common use for pairs is to build lists, which are ordered sequences of pairs linked one to the next by the cdr field. The elements of the list occupy the car fields of the pairs. The cdr of the last pair is a proper list is the empty list, (); the cdr of the last pair in an improper list can be anything other than ();

   Proper lists are printed sequences of objects separated by whitespace and enclosed in parentheses. Matching pairs of brackets ([]) may be used in place of parentheses. For example, (1 2 3) and (a [nested list]) are proper lists. The empty list is written as ().

   It is possible to create a circular list or a cyclic graph by destructively altering the car or cdr field of a pair, using set-car! or set-cdr!. Such lists are not considered *proper lists*.

*** caar, cadr, cdddr

    These procedures are defined as the composition of up to four cars and cdrs. The a's and d's between the c and r represent the application of car or cdr in order from *right to left*.

** Numbers
** Fixnums
** Flonums

   Flonums represent inexact real numbers. Implementations are required to represent as a flonum any inexact number whose lexical syntax contains no vertical bar and no exponent other than e, but are not required to represent any other inexact real number of a flonum.

** Characters

   Characters are atomic objects representing letters, digits,  special symbols such as $ or -, and certain non-graphic control characters such as space and newline. Characters are written with a #\ prefix.

** Strings

   Strings are sequences of characters and are often used as messages, character buffers, or containers for blocks of text.

** Vectors
** Bytevectors
** Symbols
** Booleans
** Hashtables

   Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the *same purpose* as association lists, but are typically mush faster when *large numbers* of associations are involved.

   An eq hashtable compares keys using the eq? (*pointer equality*) procedure and typically employs a hash function based on *object addresses*. Its hash and equivalence functions are suitable for any Scheme object.

   hash-table-hash-function returns #f for eq and eqv hashtables.

   These procedures are hash functions suitable for use with the appropriate Scheme predicates.

** Enumerations

   Enumerations are ordered sets of symbols, typically used to name and manipulate options, as with the buffer modes and file options that may be *specified* when files are created.

* Ch7. Input and Output

  All input and output operations are performed through ports.

  Ports are first-class objects, like any other object in Scheme. Like procedures, ports do not have a printed representation the way strings and numbers do.

  Ports are either binary or textual. A binary port allows a program to read or write 8-bit unsigned bytes, or "octets," from or to the underlying stream. A textual port allow a program to read or write characters.

  In many cases, the underlying stream is organized as a sequence of bytes, but these bytes should be treated as encodings for characters. In this case, a textual port may be created with a transcoder to decode bytes to characters (for input) or encode characters to bytes (for output).

  A transcoder encapsulates a codec that determines how characters are represented as bytes. Three standard  codecs are provided: a latin-1 codec, a Unicode utf-8 codec, and a Unicode-16 codec. For the latin-1 encoding, each character is represented by exactly one byte. For utf-8, each character is represented by from one to four bytes, and for utf-16, each character is represented by two or four bytes.

  The eol style affects input and output operations differently.

  A port may be buffered for efficiency, to eliminate the overhead of a call into the operating system for each byte or characters.

  Three standard buffer modes are supported: block, line, and none.

  eof :: end of file.
  eol :: end of line.

** Transcoders

   Transcoders encapsulate three values: a codec, an eol style, and an error-handling mode.
** Opening files

   If transcoder is present and not #f, it nust be a transcoders, and this procedure returns a textual input/output  port whose transcoder is transcoder. Otherwise, this procedure returns a binary input/output port.

** Standard Ports
** String and Bytevector Ports
** Opening Custom Ports
** Port Operations
** Input Operations
** Output Operations
** Convenience I/O
** Filesystem Operation
** Bytevector/String Conversions

* Ch8. Syntactic Extension

  Syntactic extensions, or macros, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.

** Keyword Bindings
** Syntax-Rules Transformers

   The syntax-rules form permits simple transformers to be specified in a convenient manner.

** Syntax-Case Transformers

   This section describes a more expressive mechanism for creating transformers, based on syntax-case, a generalized version of syntax-rules and rebuild their output with syntax. These two forms alone are sufficient for defining many syntactic extensions, including any that can be defined using syntax-rules.

** Examples

* Ch9. Records
