#+TITLE:       The Scheme Programming Language
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-07-11 Sat



* Preface

* Ch1. Introduction

** General-purpose Language

   Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters.

** The core of Scheme

   At the heart of the Scheme language is a small core of syntatic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language. An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. The extended syntatic forms and primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.

** Representation of Scheme programs

   Scheme programs share a common printed representation with Scheme data structures. As a result, any Scheme program has a nature and obvious internal representaion as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for syntactic extension facilities provided by Scheme for the definition of new syntactic in terms of existing syntactic forms and procedures. It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, as well as program transformation tools for other languages in Scheme.

** Procedure definition

   In most languages, a procedure definition is simply the association of a name with a block of code. Certain variables local to the block are the parameters of the procedure. In some languages, a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block. In others, procedures can be defined only at top level. In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.
** Tail recursion

   Scheme implementation are required to implement tail calls as jumps (gotos), so the storage overhead normally associated with recursion is avoided. As a result, Scheme programmers need master only  simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.

** Continuations

   Scheme supports the definition of arbitrary control structures with continuations. A continuation is a procedure that embodies the remainder of a program at a given point in the program. A continuation may be obtained at any time during the execution of a program. As with other procedures, a continuation is a first-class object and many be invoked at any time after its creation. Whenever it is invoked, the program immediately continues from the point where the continuation was obtained. Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.

** Syntactic extension

   These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer. Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme. Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.
** Scheme Syntax

   Scheme Programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.

   Identifies are delimited by whitespace, comments, brackets, string (double) quote ("), and hash marks(#).

** Standard printed representation

   Some Scheme values, such as procedures and ports, do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. #<description> would be used as a notation when showing the output of an operation that returns such a value, e.g., #<procedure> or #<port>
* CH2. Getting Started

** data structures and control mechanisms

   其实程序里面除了要考虑 data structure，还要考虑 control mechanisms. However 由于将 control mechanisms 硬性的规定成了 顺序流动，for循环，while 循环，if 语句分支选择，差不多没有别的了。 不可否认，这样确实很好的让 programmer 和 code reader 理解程序，但却将 programs 的种类也硬性死板了。缺少了 goto 的这种胆大妄为。
** Aggregate data structure - List

   You might notice that lists look just like procedure applications and wonder how Scheme tells them apart. That is, how does Scheme distinguish between a list of objects, (obj1 obj2), and a procedure application, (procedure arg ...)?

   In some cases, the distinction might seem obvious. The list of numbers (1 2 3 4 5) could hardly be confused with a procedure application, since 1 is a number. So, the answer might be that Scheme looks at the fist element of the list or procedure application and makes its decision based on whether that first element is a procedure or not. This answer is not good enough, since we might even want to treat a valid procedure application such as (+ 3 4) as a list. The answer is that we must tell Scheme explicitly to treat a list as a data rather than as a procedure application. We do this with quote.

   #+begin_src racket
(quote (1 2 3 4 5))
(quote ("this" "is" "a" "list"))
(quote (+ 3 4))
   #+end_src

   The quote forces the list to be treated as data. Try entering the above expressions without the quote; you will likely receive a message indicating that an exception has occurred for the first two an an incorrect answer (7) for the third.

   Because quote is required fairly frequently in Scheme code, Scheme recognizes a single quotation make (') preceding an expression an a abbreviation for quote.

   #+begin_src racket
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
   #+end_src

   Both forms are referred to as quote expressions. We often say an object is quoted when it is enclosed in a quote expression.

   A quote expression is not a procedure application, since it inhibits that evaluation of its expression. It is an entirely different syntactic form. Scheme supports several other syntactic forms in addition to procedure applications and quote expressions. Each syntactic form is evaluated differently. Fortunately, the number of different syntactic form is small.

   You might wonder why applications and variables share notations with lists and symbols. The shared notation allows Scheme programs to be represented as Scheme data, simplifying the writing of interpreters, compilers, editors, and other tools in Scheme.

   Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb. Creating a new list by adding an element to the beginning of a list is referred to as consing the element onto the list.
** Evaluating scheme expression

   Let's turn to a discussion of how Scheme evaluates the expression you type. We have already established the rules for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out in your mind a rule for evaluating procedure applications of the form

#+begin_src racket
(procedure arg1 ... argn)
#+end_src


   Here, procedure is an expression representing a Scheme procedure, amd arg1 ... argn are expressions representing its arguemts. One possibility is the following:

#+begin_src racket
; Find the value of procedure.
; Find the value of arg1
; ...
; Find the value of argn
; Apply the value of procedure to the values of arg1 ... argn.
#+end_src

   For example, consider the simple procedure application (+ 3 4). The value of + is the addition procedure, the value of 3 is the number 3, and the value of 4 is the number 4. Apply the addition procedure to 3 and 4 yields 7, so our value is the object 7.

** Procedure and other syntactic forms

   The procedure evaluation rule works for procedure applications but not for quote expression because the subexpressions of a procedure application are evaluated, whereas the subexpression of a quote expression is not. The evaluation of a quote expression is more similar to the evaluation of constant objects. The value of a quote expression of the form (quote object) is simply object.

   Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Schemer programmer; there are referred as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining sections of this chapter. Section 3.1 summarizes the core syntactic forms and introduces the syntactic extension mechanism.

** Let syntactic form

   We say the variable are bound to the values by the let. We refer to variables bound by let as let-bound variables.

   A let expression is often used to simplify an expression that would contain two identical subexpressions. Doing so also ensures that the value of the common subexpression is computed only once.

#+begin_src racket

(+ (* 4 4) (* 4 4))
(let ((a (* 4 4)))
     (+ a a))

#+end_src

   The variable bound by let are visible only within the body of the let.

   Although choosing different names can sometimes prevent confusion, showing can help prevent the accidental use of an "old" value. For example, with the original version of the preceding example, it would be impossible for us to mistakenly refer to the outer x within the body of the inner let.
** Procedure

   A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed representation as far as Scheme is concerned.

   #<procedure> to show that the value of an expression is a procedure.

   Because procedure are objects, we can establish a procedure as the value of the variable and use the procedure more than once.

   What happends when the procedure is applied somewhere outside the scope of the bindings for variables that occur free within the procedure, as in the following expressions?

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (f 'i 'am))

#+end_src

   The answer is that the same bindings taht were in effect when  the procedure was created are in effect again when the procedure is applied. This is true even if another binding for x is visible where the procedure is applied.

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (let ([x 'not-sam])
      (f 'i 'am)))

#+end_src

   Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of argument expression. For example, the two expressions below are equivalent.

#+begin_src racket

(let ([x 'a])
   (cons x x))

((lambda (x)
    (cons x x))

 'a)

#+end_src

   In fact, a let expression is a syntactic extension defined in terms of lambda and procedure application, which are both core syntactic forms.

** Top-level definitions

   A top-level definition many be established for any object, not just for procedures.

   As suggested above, top-level definitions may be shadowed by let or lambda bindings.

   Variables with top-level definitions act almost as if they were bound by a let expression enclosing all of the expression you type.
** Simple Recursion

   Readers who are familiar with other languages that provide special iteration constructs, e.g., while or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary; iteration in Scheme is expressed more clearly and succinctly via recursion.

   Recursion is more general and eliminates the need for the variable assignments required by many other languages' iteration constructs, resulting in code that is more reliable and easier to follow.
** Assignment

   Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings.

   Many languages require the use of assignments to initialize variables, separate from the declaration or binding of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to initialize them, a common source of errors in most languages.

   In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One common practice in some languages is to sequence expression evaluation with a series of assignments, as in the following procedure that finds the roots of a quadratic equation.

#+begin_src racket
(define quadratic-formula
   (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
)))
#+end_src

   Assignments are commonly used to implement procedures that must maintain some internal state.
** Lazy evaluation

   Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than once.

* Ch3. Going Further

** Syntactic extension
** More recursion

   Recursion in general  and named let in particular provide a natural way to implement many algorithms, whether iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct mechanisms.

   It often happens that one recursive call within the same expression is tail-recursive while another is not.

** Tail position

   A call is in tail position with respect to a lambda expression if its value is returned directly from the lambda expression, i.e., if nothing is left to do after the call but to return from the lambda expression. For example, a call in tail position if it is the last expression in the body in the body of a lambda expression, the consequent or alternative part of an if expression in tail position, the last subexpression of an and or or expression in tail position, the last expression in the body of a let or let rec in tail position, etc. Each of the calls to f in the expressions below are tail calls, but the calls to g are not.
