#+TITLE:       The Scheme Programming Language
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-07-11 Sat



* Preface

* Ch1. Introduction

** General-purpose Language

   Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters.

** The core of Scheme

   At the heart of the Scheme language is a small core of syntatic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language. An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. The extended syntatic forms and primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.

** Representation of Scheme programs

   Scheme programs share a common printed representation with Scheme data structures. As a result, any Scheme program has a nature and obvious internal representaion as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for syntactic extension facilities provided by Scheme for the definition of new syntactic in terms of existing syntactic forms and procedures. It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, as well as program transformation tools for other languages in Scheme.

** Procedure definition

   In most languages, a procedure definition is simply the association of a name with a block of code. Certain variables local to the block are the parameters of the procedure. In some languages, a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block. In others, procedures can be defined only at top level. In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.
** Tail recursion

   Scheme implementation are required to implement tail calls as jumps (gotos), so the storage overhead normally associated with recursion is avoided. As a result, Scheme programmers need master only  simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.

** Continuations

   Scheme supports the definition of arbitrary control structures with continuations. A continuation is a procedure that embodies the remainder of a program at a given point in the program. A continuation may be obtained at any time during the execution of a program. As with other procedures, a continuation is a first-class object and many be invoked at any time after its creation. Whenever it is invoked, the program immediately continues from the point where the continuation was obtained. Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.

** Syntactic extension

   These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer. Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme. Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.
** Scheme Syntax

   Scheme Programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.

   Identifies are delimited by whitespace, comments, brackets, string (double) quote ("), and hash marks(#).

** Standard printed representation

   Some Scheme values, such as procedures and ports, do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. #<description> would be used as a notation when showing the output of an operation that returns such a value, e.g., #<procedure> or #<port>
* CH2. Getting Started

** data structures and control mechanisms

   其实程序里面除了要考虑 data structure，还要考虑 control mechanisms. However 由于将 control mechanisms 硬性的规定成了 顺序流动，for循环，while 循环，if 语句分支选择，差不多没有别的了。 不可否认，这样确实很好的让 programmer 和 code reader 理解程序，但却将 programs 的种类也硬性死板了。缺少了 goto 的这种胆大妄为。
** Aggregate data structure - List

   You might notice that lists look just like procedure applications and wonder how Scheme tells them apart. That is, how does Scheme distinguish between a list of objects, (obj1 obj2), and a procedure application, (procedure arg ...)?

   In some cases, the distinction might seem obvious. The list of numbers (1 2 3 4 5) could hardly be confused with a procedure application, since 1 is a number. So, the answer might be that Scheme looks at the fist element of the list or procedure application and makes its decision based on whether that first element is a procedure or not. This answer is not good enough, since we might even want to treat a valid procedure application such as (+ 3 4) as a list. The answer is that we must tell Scheme explicitly to treat a list as a data rather than as a procedure application. We do this with quote.

   #+begin_src racket
(quote (1 2 3 4 5))
(quote ("this" "is" "a" "list"))
(quote (+ 3 4))
   #+end_src

   The quote forces the list to be treated as data. Try entering the above expressions without the quote; you will likely receive a message indicating that an exception has occurred for the first two an an incorrect answer (7) for the third.

   Because quote is required fairly frequently in Scheme code, Scheme recognizes a single quotation make (') preceding an expression an a abbreviation for quote.

   #+begin_src racket
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
   #+end_src

   Both forms are referred to as quote expressions. We often say an object is quoted when it is enclosed in a quote expression.

   A quote expression is not a procedure application, since it inhibits that evaluation of its expression. It is an entirely different syntactic form. Scheme supports several other syntactic forms in addition to procedure applications and quote expressions. Each syntactic form is evaluated differently. Fortunately, the number of different syntactic form is small.

   You might wonder why applications and variables share notations with lists and symbols. The shared notation allows Scheme programs to be represented as Scheme data, simplifying the writing of interpreters, compilers, editors, and other tools in Scheme.

   Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb. Creating a new list by adding an element to the beginning of a list is referred to as consing the element onto the list.
** Evaluating scheme expression

   Let's turn to a discussion of how Scheme evaluates the expression you type. We have already established the rules for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out in your mind a rule for evaluating procedure applications of the form

#+begin_src racket
(procedure arg1 ... argn)
#+end_src


   Here, procedure is an expression representing a Scheme procedure, amd arg1 ... argn are expressions representing its arguemts. One possibility is the following:

#+begin_src racket
; Find the value of procedure.
; Find the value of arg1
; ...
; Find the value of argn
; Apply the value of procedure to the values of arg1 ... argn.
#+end_src

   For example, consider the simple procedure application (+ 3 4). The value of + is the addition procedure, the value of 3 is the number 3, and the value of 4 is the number 4. Apply the addition procedure to 3 and 4 yields 7, so our value is the object 7.

** Procedure and other syntactic forms

   The procedure evaluation rule works for procedure applications but not for quote expression because the subexpressions of a procedure application are evaluated, whereas the subexpression of a quote expression is not. The evaluation of a quote expression is more similar to the evaluation of constant objects. The value of a quote expression of the form (quote object) is simply object.

   Constant objects, procedure applications, and quote expressions are only three of the many syntactic forms by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Schemer programmer; there are referred as core syntactic forms. The remaining syntactic forms are syntactic extensions defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining sections of this chapter. Section 3.1 summarizes the core syntactic forms and introduces the syntactic extension mechanism.

** Let syntactic form

   We say the variable are bound to the values by the let. We refer to variables bound by let as let-bound variables.

   A let expression is often used to simplify an expression that would contain two identical subexpressions. Doing so also ensures that the value of the common subexpression is computed only once.

#+begin_src racket

(+ (* 4 4) (* 4 4))
(let ((a (* 4 4)))
     (+ a a))

#+end_src

   The variable bound by let are visible only within the body of the let.

   Although choosing different names can sometimes prevent confusion, showing can help prevent the accidental use of an "old" value. For example, with the original version of the preceding example, it would be impossible for us to mistakenly refer to the outer x within the body of the inner let.
** Procedure

   A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed representation as far as Scheme is concerned.

   #<procedure> to show that the value of an expression is a procedure.

   Because procedure are objects, we can establish a procedure as the value of the variable and use the procedure more than once.

   What happends when the procedure is applied somewhere outside the scope of the bindings for variables that occur free within the procedure, as in the following expressions?

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (f 'i 'am))

#+end_src

   The answer is that the same bindings taht were in effect when  the procedure was created are in effect again when the procedure is applied. This is true even if another binding for x is visible where the procedure is applied.

#+begin_src racket

(let ([f (let ([x 'sam])
            (lambda (y z)
                (list x y z)))])
   (let ([x 'not-sam])
      (f 'i 'am)))

#+end_src

   Incidentally, a let expression is nothing more than the direct application of a lambda expression to a set of argument expression. For example, the two expressions below are equivalent.

#+begin_src racket

(let ([x 'a])
   (cons x x))

((lambda (x)
    (cons x x))

 'a)

#+end_src

   In fact, a let expression is a syntactic extension defined in terms of lambda and procedure application, which are both core syntactic forms.

** Top-level definitions

   A top-level definition many be established for any object, not just for procedures.

   As suggested above, top-level definitions may be shadowed by let or lambda bindings.

   Variables with top-level definitions act almost as if they were bound by a let expression enclosing all of the expression you type.
** Simple Recursion

   Readers who are familiar with other languages that provide special iteration constructs, e.g., while or for loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary; iteration in Scheme is expressed more clearly and succinctly via recursion.

   Recursion is more general and eliminates the need for the variable assignments required by many other languages' iteration constructs, resulting in code that is more reliable and easier to follow.
** Assignment

   Assignments do not create new bindings, as with let or lambda, but rather change the values of existing bindings.

   Many languages require the use of assignments to initialize variables, separate from the declaration or binding of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to initialize them, a common source of errors in most languages.

   In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One common practice in some languages is to sequence expression evaluation with a series of assignments, as in the following procedure that finds the roots of a quadratic equation.

#+begin_src racket
(define quadratic-formula
   (lambda (a b c)
       (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
          (set! minusb (- 0 b))
          (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
          (set! divisor (* 2 a))
          (set! root1 (/ (+ minusb radical) divisor))
          (set! root2 (/ (- minusb radical) divisor))
)))
#+end_src

   Assignments are commonly used to implement procedures that must maintain some internal state.
** Lazy evaluation

   Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than once.

* Ch3. Going Further

** Syntactic extension
** More recursion

   Recursion in general  and named let in particular provide a natural way to implement many algorithms, whether iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct mechanisms.

   It often happens that one recursive call within the same expression is tail-recursive while another is not.

** Tail position

   A call is in tail position with respect to a lambda expression if its value is returned directly from the lambda expression, i.e., if nothing is left to do after the call but to return from the lambda expression. For example, a call in tail position if it is the last expression in the body in the body of a lambda expression, the consequent or alternative part of an if expression in tail position, the last subexpression of an and or or expression in tail position, the last expression in the body of a let or let rec in tail position, etc. Each of the calls to f in the expressions below are tail calls, but the calls to g are not.

** Continuations

   During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. Consider the evaluation of (null? x) within the expression below.

#+begin_src racket

(if (null? x)
  (quote ())
  (cdr x))

#+end_src

   The implementation must first evaluate (null? x) and, based on its value, evaluate either (quote ()) or (cdr x). "What to evaluate" is (null? x), and "what to do with the value" is to make the decision which of (quote ()) and (cdr x) to evaluate and to do so. We call "what to do with the value" the continuation of a computation.

   Thus, at any point during the evaluation of any expression, there is a continuation ready to complete, or at least continue, the computation from that point. Let's assume that x has the value (a b c). We can isolate six continuations of (if (null? x) (quote ()) (cdr x)), the continuations waiting for:

   + 1. the value of (if (null? x) (quote ()) (cdr x)),
   + 2. the value of (null? x),
   + 3. the value of null?
   + 4. the value of x,
   + 5. the value of cdr, and
   + 6. the value of x (again).

   The continuation of (cdr x) is not listed because it is the same as the one waiting for (if (null? x) (quote ()) (cdr x)).

   Scheme allows the continuation of any expression to be captured with the procedure call/cc. call/cc must be passed a procedure p of one argument. call/cc constructs a concrete representation of the current continuation and passes it to p. The continuation itself is represented by a procedure k. Each time k is applied to a value, it returns the value to the continuation of the call/cc application. This value becomes, in essence, the value of the application of call/cc.

   If p returns without invoking k, the value returned by the procedure becomes the value of the application of call/cc.

*** Demos of continuation

   The following variation of the example above is probably the most confusing Scheme program of its size; it might be easy to guess what it returns, but it takes some thought to figure out why.

#+BEGIN_SRC racket

; most confusing Scheme program of its size;
(((call/cc (lambda (k) k))
  (lambda (x) x))
 "HEY!")

#+END_SRC

   The value of the call/cc is its own continuation, as in the preceding example. This is applied to the identity procedure (lambda (x) x), so the call/cc returns a second time with this value. Then, the identity procedure is applied to itself, yielding the identity procedure. This finally applied to "HEY!", yielding "HEY!".

-----

   Continuations used in this manner are not always so puzzling. Consider the following definition of factorial that saves the continuation at the base of the recursion before returning 1, by assigning the top-level variable retry.

#+BEGIN_SRC racket

; most confusing Scheme program of its size;
(((call/cc (lambda (k) k))
  (lambda (x) x))
 "HEY!")


; factorial
(define retry #f)

(define factorial (lambda (x)
                    (if (= x 0) (call/cc (lambda (k) (set! retry k) 1))
                        (* x (factorial (- x 1))))))


#+END_SRC

   With this definition, factorial works as we expect factorial to work, except it has the side effect of assigning retry.

#+BEGIN_SRC racket

(factorial 4) ; -> 24
(retry 1)     ; -> 24
(retry 2)     ; -> 48

#+END_SRC

   The continuation bound to retry might be described as "Multiply the value by 1, then multiply this result by 2, then multiply this result by 3, then multiply this result by 4." If we pass the continuation a different value, i.e., not 1, we will cause the base value to be something other than 1 and hence change the end result.

#+BEGIN_SRC racket

(retry 2)     ; -> 48
(retry 4)     ; -> 120

#+END_SRC

   This mechanism could be the basis for a breakpoint package implemented with call/cc; each time a breakpoint is encountered, the continuation of the breakpoint is saved so that the computation may be restarted from the breakpoint (more than once, if desired).

** Continuation Passing Style

   As we discussed in the preceding section, a continuation waits for the value of each expression. In particular, a continuation is associated with *each procedure call*. When one procedure invokes another via *nontail call*, the *called procedure* receives an implicit continuation that is responsible for completing what is left of the *calling procedure's body* plus returning to the *calling procedure's continuation*. If the call is a tail call, the called procedure simply receives the *continuation of the calling procedure*.

   We can make the continuation explicit by encapsulating "What to do" in an exaplicit procedural argument passed along on each call. For example, the continuation of the call to f in

   #+BEGIN_SRC Scheme

; explicit continuation
; -> (d b a c)
(letrec ([f (lambda (x)
              (cons 'a x))]
         [g (lambda (x)
              (cons 'b (f x)))]
         [h (lambda (x)
              (g (cons 'c x)))])
  (cons 'd (h '())))

   #+END_SRC

   conses the symbol /b/ onto the value returned to it, then returns the result of this cons to the continuation of the call to g.


   Expression written in CPS are more complicated, of course, but this style of programming has some useful applications. CPS allows a procedure to pass more than one result to its continuation, because the procedure that implements the continuation can take any number of arguments.

    At this point you might be wondering about the  relationship between CPS and the continuations captured via call/cc. It turns out that any program that uses call/cc can be rewritten in CPS without call/cc, but a total rewrite of the program (sometimes including even system-defined primitives) might be necessary.
** Internal Definitions

   In fact, internal variable definitions and letrec are practically interchangeable. The only difference, other than the obvious difference insyntax, is that variable definitions are guaranteed to be evaluated from left to right, while the bindings of a letrec may be evaluated in any order. So we cannot replace a lambda, let, or letrec body containing internal definitions with a letrec expression. We can, however, use letrec*, which, like let*, guarantees left-to-right evaluation order.

   Another different between internal definitions and letrec or letrec* is that syntax definitions may appear among the internal definitions, while letrec and letrec* bind only variables.

   The scope of a syntactic extension established by an internal syntax definition, as with an internal variable definition, is limited to the body in which the syntax definition appears.

** Modularize programs

   Internal definitions may be used in conjunction with top-level definitions and assignments to help modularize programs. Each module of a program should make visible only those bindings that are needed by other modules, while hiding other bindings that would otherwise clutter the top-level namespace and possibly result in unintended use or redefinition of those bindings. A common way of structuring a module is shown below.

** Libraries
* CH4. Procedures and Variable Bindings

** Variable References

   Syntax :: variable
   returns :: the value of /variable/

   Any identifier appearing as an expression is a variable, if a visible binding for the identifier exists, e.g., the identifier appears within the scope of a binding created by define, lambda, let, or some other variable-biding construct.

** Lambda

   Syntax :: (lambda formals body1 body2 ...)
   returns :: a procedure
   libraries :: (rnrs base), (rnrs)

   The lambda syntactic form is used to create procedures. Any _operation_ that _creates a procedure_ or _establishes local variable bindings_ is ultimately defined in terms of lambda or case-lambda.

   Procedures do not have a printed representation in the usual sense. Scheme systems print procedures in different ways; this book uses the notation #<procedure>.

** Case-Lambda

   The case-lambda syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments. case-lambda is based on the lambda* syntax form introduced in the article "A New Approach to Procedures with Variable Arity".

   Syntax :: (case-lambda clause ...)
   returns :: a procedure
   libraries :: (rnrs control), (rnrs)

   A case-lambda expression consists of a set of clauses, each resembling a lambda expression. Each clause has the form below.

   [formals body1 body2 ...]

** Local Binding

   Syntax :: (let ((var expr) ...) body1 body2 ...)
   returns :: the values of the final body expression
   libraries: (rnrs base), (rnrs)

   /let/ establishes local variable bindings. Each variable var is bound to the value of the corresponding expression expr. The body of the let, in which the variable are bound, is the sequence of subforms body1, body2 ... and is processed and evaluated like a lambda body.

   Use /let/ whenever the values in expr the values are independent of the variables and the order of evaluation is unimportant.

   Syntax :: (let* ((var expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

   /let*/ is similar to /let/ except that the expression expr ... are evaluated in sequence from left to right, and each of these expressions is within the scope of the variables to the left. Use /let*/ when there is a linear dependency among the values or when the order of evaluation is important.

   Syntax :: (letrec ((var expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

   /letrec/ is similar to /let/ and /let*/, except that all of the expression expr ... are within the scope of the variables var .... /letrec/ allows the definition of mutually recursive procedures.

** Multiple Values

   Syntax :: (let-values ((formal expr) ...) body1 body2)
   Syntax :: (let*-values ((formal expr) ...) body1 body2)
   returns :: the values of the final body expression
   libraries :: (rnrs base), (rnrs)

** Variable Definitions

   Syntax :: (define var expr)
   Syntax :: (define var)
   Syntax :: (define (var0 var2 ...) body1 body2 ...)


** Assignment

   syntax :: (set! var expr)
   returns :: unspecified
   libraries :: (rnrs base), (rnrs)
