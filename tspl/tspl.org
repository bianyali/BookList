#+TITLE:       The Scheme Programming Language
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-07-11 Sat



* Preface

* Ch1. Introduction

** General-purpose Language

   Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters.

** The core of Scheme

   At the heart of the Scheme language is a small core of syntatic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language. An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. The extended syntatic forms and primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.

** Representation of Scheme programs

   Scheme programs share a common printed representation with Scheme data structures. As a result, any Scheme program has a nature and obvious internal representaion as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for syntactic extension facilities provided by Scheme for the definition of new syntactic in terms of existing syntactic forms and procedures. It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, as well as program transformation tools for other languages in Scheme.

** Procedure definition

   In most languages, a procedure definition is simply the association of a name with a block of code. Certain variables local to the block are the parameters of the procedure. In some languages, a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block. In others, procedures can be defined only at top level. In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.
** Tail recursion

   Scheme implementation are required to implement tail calls as jumps (gotos), so the storage overhead normally associated with recursion is avoided. As a result, Scheme programmers need master only  simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.

** Continuations

   Scheme supports the definition of arbitrary control structures with continuations. A continuation is a procedure that embodies the remainder of a program at a given point in the program. A continuation may be obtained at any time during the execution of a program. As with other procedures, a continuation is a first-class object and many be invoked at any time after its creation. Whenever it is invoked, the program immediately continues from the point where the continuation was obtained. Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.

** Syntactic extension

   These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer. Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme. Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.
** Scheme Syntax

   Scheme Programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.

   Identifies are delimited by whitespace, comments, brackets, string (double) quote ("), and hash marks(#).
** Standard printed representation

   Some Scheme values, such as procedures and ports, do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. #<description> would be used as a notation when showing the output of an operation that returns such a value, e.g., #<procedure> or #<port>
* CH2. Getting Started

** data structures and control mechanisms

   其实程序里面除了要考虑 data structure，还要考虑 control mechanisms. However 由于将 control mechanisms 硬性的规定成了 顺序流动，for循环，while 循环，if 语句分支选择，差不多没有别的了。 不可否认，这样确实很好的让 programmer 和 code reader 理解程序，但却将 programs 的种类也硬性死板了。缺少了 goto 的这种胆大妄为。
** Aggregate data structure - List

   You might notice that lists look just like procedure applications and wonder how Scheme tells them apart. That is, how does Scheme distinguish between a list of objects, (obj1 obj2), and a procedure application, (procedure arg ...)?

   In some cases, the distinction might seem obvious. The list of numbers (1 2 3 4 5) could hardly be confused with a procedure application, since 1 is a number. So, the answer might be that Scheme looks at the fist element of the list or procedure application and makes its decision based on whether that first element is a procedure or not. This answer is not good enough, since we might even want to treat a valid procedure application such as (+ 3 4) as a list. The answer is that we must tell Scheme explicitly to treat a list as a data rather than as a procedure application. We do this with quote.

   #+begin_src racket
(quote 1 2 3 4 5)
(quote ("this" "is" "a" "list"))
(quote (+ 3 4))
   #+end_src

   The quote forces the list to be treated as data. Try entering the above expressions without the quote; you will likely receive a message indicating that an exception has occurred for the first two an an incorrect answer (7) for the third.

   Because quote is required fairly frequently in Scheme code, Scheme recognizes a single quotation make (') preceding an expression an a abbreviation for quote.

   #+begin_src racket
'(1 2 3 4)
'((1 2) (3 4))
'(/ (* 2 -1) 3)
   #+end_src

   Both forms are referred to as quote expressions. We often say an object is quoted when it is enclosed in a quote expression.

   A quote expression is not a procedure application, since it inhibits that evaluation of its expression. It is an entirely different syntactic form. Scheme supports several other syntactic forms in addition to procedure applications and quote expressions. Each syntactic form is evaluated differently. Fortunately, the number of different syntactic form is small.

   You might wonder why applications and variables share notations with lists and symbols. The shared notation allows Scheme programs to be represented as Scheme data, simplifying the writing of interpreters, compilers, editors, and other tools in Scheme.

   Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb. Creating a new list by adding an element to the beginning of a list is referred to as consing the element onto the list.
