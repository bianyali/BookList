#+TITLE:       Seven Languages in Seven Weeks
#+AUTHOR:      Yali Bian
#+EMAIL:       byl.lisp@gmail.com
#+DATE:        2015-09-04 Fri


* Ruby
* Io
* Prolog
* Scala

  强类型是一种思想上的对于事物的有清晰定义的表现，虽然可能会让某些表示变得繁琐，但是在思维上，却是清晰的。

  面向对象的类集数据和行为于一身。

  面向对象是将一些列的相关的东西放到一个里面，但是这样，就会将数据和函数太过相关了吧。函数相关的应该是 type 和 函数。
  对象相关的是，一个集里面的某个 变量 和 函数。所以，这个里面的函数，处理外进的需要改变，其他的都不需要吧。关键就是为了将外进的和本身的进行隔离吧。。。

  既然，class 或 对象 的目的就是将一个data 和其相关的 操作，封装起来，这也无可厚非。只是修建 class 的时候，不同而已。这和 haskell 的强大的 type system 不就是相同的么。只是将数据类型和数据类型操作，以及 对象具体数据和其对应操作两种变现和描述形式吧。 两种方案，哪种更加具有明显的思维的记忆和区分性，对于不同类型的哪种更好。

  Haskell 使用 typeclass 来表明其所有的操作函数，java 则是使用类中声明的抽象类，接口或继承的函数操作。类这种方式，可以让类型系统中的操作也相应的继承下来？？？那么Haskell 的类型系统呢？？？

  val 和 var 的对比，就像是 一个人 和 一个职位的对比一样，人生世界中，一个人是不可以替代的，他就是他。但是一个职位是可以有不同的人替代的，班长，就是班长，只要符合要求的都可以放到这里。所以，这两种类型，都是自然界符合思考状态的。z

* Erlang

  除了语法，和没有强大的类型系统，其他的还好。数据表现能力不住。并发性函数，多了一种思维，让一个功能模块，干真正自己的事情。

* Clojure

  在所有函数式语言中，诸如 列表（list），元组（tuple）这样的核心数据结构往往承担着更加繁重的工作。

  和列表一样，向量也是元素的有序集合。向量是为随机访问优化的。

  向量也可以是函数.

  其实 set 也是函数。set不仅仅是一个set的数据，还同时是一个函数，可以用来判别元素是否属于该set的成员。

  说明所有的数据都可以当成 函数使用，这回事，就要有一个强大的类型系统，实现，对于不同的数据做函数，不同的类型数据做其参数时，都有不同的逻辑值。

  以冒号: 开始的词是关键词，类似 Ruby 中的符号或着 Prolog 中的原子。类似命名事物的形式在 Clojure 里有两种：关键字和符号。符号指向其他东西，而关键词指向自身。


** Function

   函数是所有 lisp 语句的核心。

   // Racket 将注释内容放到 contract 里面，将核心算法功能放到 define lambda 中，而将其他的接口信息以及api文档说明信息都放到contract里面。（包括类型）。

   Racket 好像还没有自动生成的说明文档的。。。

**  Yoda and the Force
**  An Eye for Evil

    Clojure 使用 reference 来表示一个内容可变的东西。就像我说的，世界上有两种类型的东西，一种就是附属性指代，指代一个object，当object没了，这个指代也就没了，不可能指向其他的。
    还有一种就是 参考指代，这种指代是为了一代某种类型的任意值的，这个就如同书架上的书，不管什么书籍，都可以放到书架的这个位置。 而某个书籍的名字就不同了，如果书没了，这个名字也就没有意义了。

    所以，另外的 参考性指代是不属于 某个 object 的独立存在的一个object，这个 object 的是用来存储别的 object 的。这种确是可以叫成是 box object，用来装其他东西的，不是一个名字，是一个object。

* Haskell

  将可变性的变量，命名为“box” 或 “store” 或着“holder” 或者 “vessel” "repo" "can".

  在 Haskell 中，中，if 是一个函数，而不是一个结构。
