* COMMNET

  1. 代码就是精确的思维
     代码并不是让计算机干什么，而是自己的精确的想法，即使没有计算机，也可以明白自己的想法。 计算机只不过是能够理解并精确的执行这种想法。

  2. 将思想写下来
     人们的行为，如果只是凭感觉去做，那永远不能对这种思想熟悉得掌握。 只有将这种思想写下来，才是真正得掌握她。 如果这种思想，针对的是同一种数据结构，那么这种思想可以扩展开来。如果这种思想，对应到不同的数据上面，也就不能将这种思想适用开来。

  3. 操纵世界的program
     现在的code只能操纵数据，操纵信息，如果将program和复杂得机器结合起来，就可以操纵环境。

  4. 语言等效性
     根据语言的等效性，所有的语言实现得功能，另外一种语言也是肯定能够实现得，只是代码量得问题而已。 所以，系统可以适用汇编，可以是机器码，可以是c-lang，都可以将上面得语言编译成这类底层的语言。

  5. 语言的核心
     语言的核心是procedure and data，将 data 全部用 list 代表，将 procedure 全部用 list 代表，具体的 list 代表方式，不同就是不同的 lisp 方言核心。 各种不同的基础的数据类型，都可以用list表示。 然后统一的算法，来统一自己的思想。
     In this chaper we will deal only with simple numberical data so that we can focus on the rules for building procedures. In later chapers, we will see that these same rules allow us to build procedures to manipulate compound data as well.
     语法核心需要有一些 primitive data and primitive procedure process these datal. 通常，programming 的primitive 都是 数值，boolean，string 相关的数据。 但是，programing language 可以有，也可以规定，其他的atom。
     Expression represanting numbers may be combined with an expression representing a primitive procedure to form a compound expression that represents the application of the procedure to those numbers.
     对于数据的操作，对于procedure，就应该有两种东西，(operater data data data)

  6. 关于special form
     可不可以不将这些special form 放到 括号里面，而括号里面的都是 combination 类型的执行方式。

  7. recursion and pattern recognation
     都是为了实现对了事物的认识，然后对于这个事物的特征，提供解决方案。 如果这个事物是无规则的，也就是没有特征的，也就无法进行模式识别，也就无法进行recursion。 最复杂的模式也就是正则表达式，最复杂的正则表达式可以使用recursion来解决。一般的最简单的事物的模式，也就是最简单的重复，对于这种最简单的重复，也就是使用iteration来对付就可以了。

  8. lambda 本来就是 primitive

     对于产生函数的expression，虽然有了理解，但是始终感觉执行产生了什么东西，有些疑问，毕竟，记住一个数字，一个data，是比较容易的，虽然也是比较抽象的，但是，我已经习惯了 1 2 3 等这类的data的抽象，而让我记忆，甚至连理解一个lambda表达式确实有些看着不顺眼。
     lambda 把它当成 atom, 它和其他data相同，本来就是 data， 只有当他存在于 expression 中的第一个位置的时候，才是要执行的procedure：
     (lambda (x) x) ; 就是一种与众不同，独一无二的数据，一种思想形容方式
     ((lambda (x) x) x) ; 将 lambda 进行解析，这是，就是进行substitution的时候。
     这样进行对lambda的理解也就正确了。

  9. 函数的含义
     对于世界问题的解决，就是将问题进行模式识别，对于不同的模式进行不同的处理。当然，既然要进行模式识别，说明这个世界被定义为问题的东西是有规则的，即使这个规则多么的杂乱无章。 对于这个有规则的东西，其中的一个规则，我们可以用一个函数来进行描述和解决。 对于一个这个小规则的大规则，我们用一个包含这个函数的算子，也就是高阶函数来表示。 然后这样一直下去，就可以实现整个问题的解决了。 也就是说，函数，是对于正则表达式的现实生活问题的解决。 谁能够好的实现这个抽象，谁就能够好的解决现实问题。 如果遇到的困难，都不能描述出来，这是个什么问题，你怎么解决呢？ 也就不存在所谓的算法了。。。

  10. Functional Programming
      函数式编程 (Functional programming) 或者是函数程序设计，又称为泛函编程，是一种编程范式，他讲电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。 函数编程语言最重要的基础就是lambda演算(lambda calculus). 而且lambda演算的函数可以接受函数当做输入和输出。
      和命令式编程相比，函数式编程强调程序的执行结果比执行过程更重要，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推到复杂的运算，而不是设计一个复杂的执行过程。

      为什么有括号，每个括号，代表一层访问是从哪里开始的，执行是在那一层。 对于数据来说，括号，代表的是层次，是更加标准的对于数据的描述。 对于程序来说，括号是运算的孙逊，一定要这么理解，比如(+ (* 1 2) 3), 这样，是个人都知道他的运算顺序. 只有一个潜规则就行： 执行是从外括号向内括号扩展的。 而 1*2+3*4， 这只能进行分析，告诉电脑如何分析才行，简直就是过度设计的结果。


* QUOTE

    1. what matter
       It doesn't matter much what the programs are about or what applications they server. what does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs.

    2. A computer is like a violin
       A computer is like a violin. You can imagine a novice trying first a phonograph and then a violin.

    3. how to make general ideas?
       The acts of the mind, wherein it exerts its power over simple ideas, are chiefly three:
       1. Combining several simple ideas into one compound one, and thus all complex ideas are made.
       2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at one, by which it gets all its ideas of relations.
       3. The third is separating them from all other ideas that accompany them in their real existence: this is called abtraction, and thus all its general ideas are made.

    4. sorcerer's spell
       The programs we use to conjure processes are like a sorcerer's spells. They are carefully composed from symbolic expressions in arcane and esoteric programming languages that prescribe the tasks we want our processes to perform.

    5. The Elements of Programming
       A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form complex ideas. Every powerful language has three mechanisms for accomplishing this:

       1. primitive expressions, which represent the simplest entities the language is convernted with,
       2. means of combination, by which compound elements are built from simpler ones, and
       3. means of abstraction, by which compound elements can be named and manipulated as units.

       In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distincinct). Informally, data is "stuff" that we want to manipulate, and procedures are descriptions of the rules for manipulating the data. Thus, any powerful programming language should be able to describe primative data and primative procedures and should have methods for combining and abstracting procedures and data.

    6. Combinations
       Expressions such as these, formed by delimiting a list of expressions within parentheses in order to denote application, are called combinations. The leftmost element in the list is called the operator, and the other elements are called operands. and the other elements are called operands. The value of a combination is obtained by applying the procedure specified by the ooperator to the arguments that are the values of the operands.

    7. name
       A critical aspect of programming language is the means it provide for using names to refer to computational object. We say that the name identifies a variable whose value is the object.

    8. define
       In the Scheme dialect of Lisp, we name things with define.
       In this book, we do not show the interpreter's response to evaluating definitions, since this is highly implementation-dependent.
       In general, computational objects may have very complex structures, and it would be extremly inconvenient to have to remember and repeat their details each time we want to use them. Indeed, complex programs are contructed by building, step by step, computational objects of increasing complexity. The interpreter makes this step-by-step program construction particularly convenient because name-object associations can be created incrementally in successive interactions.

    9. Compound procedures
       Compound procedures are used in exactly the same way as primitive procedures. Indeed, one could not tell by looking at the definition of square given above whether square was built into the interpreter, like + and *, or defined as a compound procedure.

    10. Substitution model
        The process we have just described is called the substitution model for procedure application. It can be taken as a model that determines the "meaning" of procedure application, insofar as the procedures in this chapter are concerned. However, there are two points that should be stressed:
        * The purpose of the substitution is to help us think about procedure application, not to provide a description of how the interpreter really works. Typical interpreters do not evaluate procedure applications by manipulating the text of a procedure to substitute values for the formal parameters. In practice, the "substitution" is accomplished by using a local environment for the formal parameters. We will discuss this more fully in Chaper 3 and Chapter 4 when we examine the implementation of an interpreter in detail.
        * Over the course of this book, we will present a sequence of increasingly elaborate models of how interpreters work, culminating with a complete implementation of an interpreter and compiler in Chpter 5. The substitution model is only the first of these models -- a way to get started thinking formally about evaluating process. In general, when modeling phenomena in science and engineering, we begin with simplifed, incomplete models. As we examine things in greater detail, these simple models become inadequate and must be replaced by more refined models. The substitution model is no exception. In particular, when we address in Chaper 3 the use of procedures with "mutable data", we will see that the substitution model breaks down and must be replaced by a more complicated model of procedure application.

    11. Special form
        Notice that "and" and "or" are special forms, not procedures, because the subexpressions are not necessarily all evaluated. "not" is an ordinary procedure.

    12. Procedures and functions
        Procedures, as introduced above, are much like ordinary mathematical functions. They specify a value that is determined by one or more parameters. But there is an important difference between mathematical functions and computer procedures. Procedures must be effective.
        The contrast between function and procedure is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it it sometimes referred to, the distinction between declarative knowledge and imperative knowledge. In mathmatics we are usually concerned with declarative (waht is) descriptions, whereas in computer science we usually concerned with imperative (how to) descriptions.

    13. Declative and imperative descriptions
        Declative and imperative descriptions are intimately related, as indeed are mathematics and computer science. For instance, to say that the answer produced by a program is "correct" is to make a declarative statement about the program. There is a large amount of research aimed at establishing techniques for proving that programs are correct, and much of the technical difficulty of this subject has to do with negotiating the transition between imperative statements (from which programs are constructed) and declarative statements (which can be used to deduce things). In a relative vein, an important current area in programming-language design is exploration of so-called very high-level language, in which one actually programs in terms of declarative statements. The idea is to make interpreters sophisticated enough so that, given "what is" knowledge specified by the programmer, they can generate "how to" knowledge automatically. This cannot be done in general, but there are important areas where progress has been made. We shall revisit the idea in Chaper 4.

    14. Tail recursion
        Readers who are worried about the efficiency issues involved in using procedure calls to implement iteration should note the remark on "tail recursion" in Secion 1.2.1

    15. Block structure
        Embeded definitions must come first in a procedure body. The management is not responsible for the consequences of running programs that interwine definition and use.

    16. In addition to Elements of programming
        We have now considered elements of programming: We have used primitive arithmetic operations, we have combined these operations, and we have abstracted these composite operations by defining them as compound procedures. But that is not enough to enable us to say that we know how to program. Our situation is analogous to that of someone who has  learned the rules for how the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice chess player, we don't yet know the common patterns of usage in the domain. We lack the knowledge of which moves are worth making (which procedures are worth defining). We lack the experience to predict the consequences of making a move (executing a procedure).
        The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer, just as it is in any synthetic, creative activity.
        So it is with programming, where we are planning the course of action to be taken by a process and where we control the process by means of a program. To become experts, we must learn to visulize the processes generated by various types of procedures. Only after we have developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.

    17. Procedure
        A procedure is a pattern for the local evolution of a computational process. It specifies how each stage of the process is built upon the previous stage.

    18. Iterative process
        In general, an iterative process is one whose state can be summarized by a fixed number of state variables, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate. In computing n!, the number of steps required grows linearly with n. Such a process is called linear iterative process.

    19. Recursive process
        Consider the first process. The substitution model reveals a shape of expasion followed by contraction. The expansion occurs as the process builds up a chain of deferred operations (in this case, a chain of multiplications). The contraction occurs as the operations are actually performs. This type of process, characterized by a chain of deferred operations, is called a recursive process. Carrying out this process requires that the interpreter keep track of the operations to be performed later on. In the computation of n!, the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with n (is proportional to n), just like the number of steps. Such a process is called a linear recursive process.

    20. Recursive VS. Iterative
        Ihe contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point. If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three program variables. Not so with the recursive process. In this case there is some additional "hidden" information, maintained by the interpreter and not contained in the program variables, which indicates "where the process is" in negotiating the chain of deferred operations. The longer the chain, the more information must be maintained.
        When we discuss the implementation of procedures on register machines in Chaper 5, we will see that any interative process can be realized "in hardware" as a machine that has a fixed set of regiesters and no auxiliary memory. In contrast, realizing a recursive process requires a machine that uses an auxiliary data structure known as a stack.

    21. Recursive Process VS. Recursive Procedure
        In contrasting iteration and recursion, we must be careful not to confuse the notion of a recursive process with the notion of a recursive procedure. When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers (either directly or indirectly) to the procedure itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a procedure is written. It may seem disturbing that we refer to a recursive procedure such as fact-iter as generating an iteractive process. However, the process really is iterative: Its sttate is captured completely by its three state varibles, and an interpreter need keep track of only three variables in order to execute the process.
        With a tail-recursive implementation, iteration can be expressed using the ordinary procedure call mechanism, so that special iteration constructs are useful only as syntactic sugar.

    22. Tree Recursion
        Another common pattern of computation is called tree recursion. One should not conclude from this that tree-recursive processes are useless. When we consider processes that operate on hierarchically structured data rather than numbers, we will find that tree recursion is a natural and powerful tool. But even in numerical operations, tree-recursive processes can be useful in helping us to understand and design programs. For instance, although the first fib procedure is much less efficient than the second one, it is more straightforward, being little more than a translation into Lisp of the definition of the Fibonacci sequence. To formulate the iterative algorithm required noticing that the computation could be recast as an iteration with three state variables.

    23. Process and Procedure
        The process that a procedure genetates is of course dependent on the rules used by the interpreter. As an expample, we were to interpret this procedure using normal-order evaluation, or applicative-order evaluation.

    24. Procedure we need
        We have seen that procedures are, in effect, abstractions that describes compound operations on numbers independent of the particular numbers (particular numbers/parameters).

        (define (cube x) (* x x x))

        We are not talking about the cube of a particular number, but rather about a method for obtaining the cube of any number. Of course, we could get along without ever defining this procedure, by always writing expressions such as:

        (* 3 3 3)
        (* x x x)
        (* y y y)

        and never mentioning cube explicitly. This would place us at a serious disadvantage, forcing us to work always at the level of the paricular operations that happen to be primitives in the language (multiplication, in this case) rather than in terms of highter-level operations. Our programs would be able to compute cubes, but our language would lack the ability to express the concept of cubing. One of the things is the ability to build abstractions by assigning names to common patterns and then to build abstractions directly. Procedures provide this ability. This is why all but the most primitive programming languages include mechanisms for defining procedures.

    25. Higher-order Procedures
        This section shows how higher-order procedures can serve as powerful abstraction mechanisms, vastly increasing the expressive power of our language. As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs and to build upon them and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order procedures is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled like other putational elements.

    26. First-class
        In general, programming language impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the "rights and privileges" of first-class elements are:
        * They may be named by variables.
        * They may be passed as arguments to procedures.
        * They may be returned as the results of procedures.
        * They may be included in data structures.

        Lisp, unlike other common programming languages, awards procedures full first status. This poses challenages for efficient implementation, but the resulting gain in expressive power is enormous.
        The major implementation cost of first-class procedures is that allowing procedures to be returned as values requires reserving storage for a procedure's free variables even while the procedure is not executing. I the Scheme implementation we will study in Section 4.1, these variables are stored in the procedure's environment.
